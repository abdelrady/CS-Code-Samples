<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0039)http://www2.webng.com/amrlearn/130.html -->
<HTML><HEAD><TITLE>My Laboratory Project Containing All Algorithms</TITLE><LINK 
href="130_files/stylesheet.css" type=text/css rel=stylesheet>
<META http-equiv=Content-Type content="text/html; charset=UTF-8">
<META 
content="Computer Graphics, My Laboratory Project Containing All Algorithms " 
name=description>
<META 
content="Free projects,source codes, Computer Graphics, Computer, Graphics, My, Laboratory, Project, Containing, All, Algorithms, " 
name=keywords>
<META content="Copyright 2007 Amr Saber" name=copyright>
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY>
<CENTER>
<DIV id=header>
<SCRIPT type=text/javascript><!--
google_ad_client = "pub-9653171024150495";
google_alternate_color = "C3D9FF";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text";
//2007-02-02: header
google_ad_channel = "7161698987";
//--></SCRIPT>

<SCRIPT src="130_files/show_ads.js" type=text/javascript>
</SCRIPT>
</DIV></CENTER>
<DIV id=index>
<H3>Goooooooogle</H3>
<SCRIPT type=text/javascript><!--
google_ad_client = "pub-9653171024150495";
google_alternate_color = "C3D9FF";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_ad_type = "text";
//2007-02-02: header, right
google_ad_channel = "7161698987+2593520185";
//--></SCRIPT>

<SCRIPT src="130_files/show_ads.js" type=text/javascript>
</SCRIPT>
</DIV>
<DIV id=index2>
<H3>Goooooooogle</H3>
<SCRIPT type=text/javascript><!--
google_ad_client = "pub-9653171024150495";
google_alternate_color = "C3D9FF";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_ad_type = "text";
google_ad_channel = "";
//--></SCRIPT>

<SCRIPT src="130_files/show_ads.js" type=text/javascript>
</SCRIPT>
</DIV>
<DIV id=content>
<H3>My Laboratory Project Containing All Algorithms</H3><TEXTAREA>Project.cpp
-----------
/************************************************************************
**************************************************************************
--------------------		Graphics Course Algorthims		---------------------- 
**************************************************************************
**************************************************************************/
#include&lt;windows.h&gt;
#include&lt;math.h&gt;
#include"animation_2D.h"
#include"ellipse_circle.h"
#include"Liagn_Cliping.h"
LRESULT CALLBACK WndProc(HWND , UINT , WPARAM ,LPARAM);
static char gszClassName[] = "MyWindowClass";
static HINSTANCE ghInstance = NULL;
float Xmin=50, Xmax=700,Ymin=50, Ymax=450;
float xx1,yy1,xx2,yy2;
int WINAPI WinMain(HINSTANCE hInstance , HINSTANCE hprevInstance , LPSTR lpCmdLine ,int nCmdShow)
{
		WNDCLASSEX WndClass;
		HWND hwnd;
		MSG Msg;
		ghInstance = hInstance ;
		WndClass.cbSize = sizeof(WNDCLASSEX);
		WndClass.style = NULL;
		WndClass.lpfnWndProc = WndProc ;
		WndClass.cbClsExtra =0;
		WndClass.cbWndExtra = 0;
		WndClass.hInstance =ghInstance ;
		WndClass.hIcon = LoadIcon(NULL,IDI_APPLICATION);
		WndClass.hCursor =LoadCursor(NULL ,IDC_ARROW);
		WndClass.hbrBackground = (HBRUSH)(COLOR_WINDOW+2);
		WndClass.lpszMenuName = NULL ;
		WndClass.lpszClassName = gszClassName ;
		WndClass.hIconSm = LoadIcon(NULL , IDI_APPLICATION);
	if(!RegisterClassEx(&amp;WndClass))
	{
		MessageBox(0, "window registeration failed!!","error",MB_ICONSTOP|MB_OK);
		return 0;
	}

	hwnd =CreateWindowEx(WS_EX_STATICEDGE , gszClassName ,"	Laboratory Exam for(Computer Graphics)",WS_OVERLAPPEDWINDOW ,
		CW_USEDEFAULT ,CW_USEDEFAULT,1320,1240,NULL,NULL,ghInstance,NULL);
	if(hwnd == NULL)
	{
		MessageBox(0,"windows greated failed!!","Error" ,MB_ICONSTOP|MB_OK);
         return 0;
	}
	ShowWindow(hwnd,nCmdShow);
	UpdateWindow(hwnd);
	while(GetMessage(&amp;Msg ,NULL ,0,0))
	{
		TranslateMessage(&amp;Msg);
		DispatchMessage(&amp;Msg);
	}
	return Msg.wParam;
}
//====================================================================
LRESULT CALLBACK WndProc(HWND hwnd ,UINT Message ,WPARAM wparam ,LPARAM
						 lparam)
{
	COLORREF C1=RGB(0,0,255),C4=RGB(255,255,255);
	COLORREF C2=RGB(255,0,0),C3=RGB(0,0,0),color1=RGB(180,0,120);;
	bool flg=true;
	HDC      hdc1,hdc2,hdc3,hdc4;
	HDC hdc;
	hdc=GetDC( hwnd );
	COLORREF GRND=GetPixel(hdc,0,0);
	
	float dx=.9,dy=.9;
//	::SelectObject(hdc,wpen);
	TextOut(hdc,250,10,"Graphics Course Algorthims",26);

	TextOut(hdc,50,470,"Powed By:",9);
	
	TextOut(hdc,150,485,"Amr Saber Nasser",27);
	TextOut(hdc,50,485,"Section : 2",11);
	
	TextOut(hdc,170,500,"Hosam El Din Mostafs",19);
	TextOut(hdc,50,500,"Section : 3",11);
	//int h=500,k=120;

	TextOut(hdc,Xmax-50,Ymax+30,"Under Supervision",20);
	TextOut(hdc,Xmax-70,Ymax+60,"Prof/Adel Abo Magd",20);
	double val=10.0;int i,s;int response=0;
	for(int a=1;a&lt;10;a+=2)
	{
		Draw_Window(Xmin-a,Ymin-a,Xmax+a,Ymax+a,RGB(45,125,0),hdc);
		//clipping
		Liagn_Barsky(Xmax,Ymax-a*5,Xmax-a*5,Ymax,RGB(45,125,0),hdc);//left bottom
		Liagn_Barsky(Xmax,Ymin+a*5,Xmax-a*5,Ymin,RGB(45,125,0),hdc);//left top
		Liagn_Barsky(Xmin,Ymin+a*5,Xmin+a*5,Ymin,RGB(45,125,0),hdc);//right top
		Liagn_Barsky(Xmin+a*5,Ymax,Xmin,Ymax-a*5,RGB(45,125,0),hdc);//right bottom
	}
	HDC hd=GetDC(hwnd);
	switch(Message)
	{
	case WM_CLOSE :
		response=MessageBox(hwnd,"Are You Sure You Want To Exit","Exit",MB_ICONEXCLAMATION | MB_YESNO);
			if(response==IDYES)
		DestroyWindow(hwnd);
			else return false;
		break ;
	case WM_DESTROY:
		PostQuitMessage(0);
		break ;
	case WM_RBUTTONDOWN:
		hdc1=GetDC(hwnd);
		//	xx1 = LOWORD(lparam);
		//	yy1 = HIWORD(lparam);
			ReleaseDC(hwnd,hdc1);
	break;
	case WM_LBUTTONDOWN:
		hdc2=GetDC(hwnd);
		xySystem( hdc2, C1, C2);
		//xx2 = LOWORD(lparam);
		//yy2 = HIWORD(lparam);
		//Liagn_Barsky(xx1,yy1,xx2,yy2,C1,hdc2);
		ReleaseDC(hwnd,hdc2);
	break;
//________________________________________________________________________
		case WM_CHAR:
			{
				switch (char(wparam))
				{
				case(' '):
						hdc3=GetDC( hwnd );
						for(s=5;s&lt;=10;s++)
						Circle( hdc3,100+s );
						//Boundary_Filling( 200,200, RGB(100,0,100), RGB(0,0,255),hdc3);
						Fan(hdc3,C1);
						ReleaseDC(hwnd,hdc3);
						break;
			case('e'):
					hdc4=GetDC( hwnd );
					Scaling_animat(dx,dy,hdc4,C1);
					for(i=1;i&lt;7;i++)
						{
							polynomial_ellipse(val,50, color1, hdc4);
							val=10 * i;
						}
					Sleep(2000);
					for(i=1;i&lt;7;i++)
						{
							MidPoint_ellipse(hdc4,val,50 ,C4);
							val=10 * i;
						}
					ReleaseDC(hwnd,hdc4);
					break;
			case 'c':
				{
					hd=GetDC( hwnd );
					xySystem( hd, GRND,GRND);
					break;
				}
				case('q'):
					DestroyWindow(hwnd);
				}
			}//end case keyboard char
	default:
		return DefWindowProc(hwnd,Message,wparam,lparam);
	}
	return 0;
}
/************************************************************************
*************************************************************************
===============		Amr Saber    =============
*************************************************************************
________________E-mail: goodamr@gmail.com__________________
**************************************************************************/
	

animation_2D.h
--------------
//////////////
--------------

#include"Line.h"
/*************************************************************************
--------------	 Translation , Rotation , Scaling , Animation	-------------------- 
**************************************************************************
**************************************************************************/
struct Matrix
{
	float elm[3][3];
};
struct Vector
{
	float elm[3];	

};
//----------------
struct Scal_Matrix 
{
	float elm[2][2];
};

struct Scal_Vector
{
	float elm[2];
};

void identy(Matrix &amp;M)
{
	for(int i=0;i&lt;3;i++)
		for(int j=0;j&lt;3;j++)
			M.elm[i][j]=(i==j);
}
/*==================================*/
Matrix trans_matrix(float dx,float dy)
{
	Matrix mat;
	identy(mat);
	mat.elm[0][2]=dx;
	mat.elm[1][2]=dy;
	return mat;
}
//**************************
Vector MUL(Matrix M,Vector GV)
{
	Vector RV;
	for(int i=0;i&lt;3;i++)
	{
		RV.elm[i]=0;
		for(int j=0;j&lt;3;j++)
			RV.elm[i]+=M.elm[i][j]*GV.elm[j];
	}
	return RV;
}
Vector translation(float X,float Y,float dx,float dy)
{
		Vector V;
		V.elm[0]=X, V.elm[1]=Y, V.elm[2]=1;
		Matrix M=trans_matrix(dx,dy);
		return Vector(MUL(M,V));
}
//===================================
Vector Rotate(float O,float x,float y)
{
	Matrix Rm;
	float h=200,k=200;
	identy(Rm);
	Rm.elm[0][0]=cos( O );
	Rm.elm[0][1]=-sin( O );
	Rm.elm[0][2]=(-h*cos(O)+k*sin(O)+h);
	Rm.elm[1][1]=cos(O);
	Rm.elm[1][0]=sin(O);
	Rm.elm[1][2]=(-h*sin(O)-k*cos(O)+k);
	
	Vector vec;
	vec.elm[0]=x;
	vec.elm[1]=y;
	vec.elm[2]=1;
    return	Vector (MUL(Rm,vec) );
}
Scal_Vector  MUl_scal(Scal_Matrix  SM,Scal_Vector SV)
{
	Scal_Vector RV;
	RV.elm[0]=SM.elm[0][0]*SV.elm[0];
	RV.elm[1]=SM.elm[1][1]*SV.elm[1];
	return RV;
}
Scal_Vector scaling(float X,float Y,float Sx,float Sy)
{
	Scal_Matrix M;
	Scal_Vector V;
	M.elm[0][0]=Sx;		M.elm[0][1]=0;
	M.elm[0][1]=0;		M.elm[1][1]=Sy;
	V.elm[0]=X;			V.elm[1]=Y;
	return Scal_Vector( MUl_scal(M,V) );
}
struct Point
{
	float x,y;
	Point()
	{}
	Point(float a,float b)
	{
		x=a;y=b;
	}
};
void Boundary_Filling(int x, int y, COLORREF fillColor, COLORREF boundaryColor,HDC hdc)
{
	COLORREF color = GetPixel(hdc, x, y);
	if(color == boundaryColor || color == fillColor || x&lt;0 || y&lt;0)
		return;
	else
	{
		SetPixel(hdc, x, y, fillColor);
		Boundary_Filling( x-1, y, fillColor, boundaryColor,hdc);
		Boundary_Filling( x, y-1, fillColor, boundaryColor,hdc);
		Boundary_Filling( x+1, y, fillColor, boundaryColor,hdc);
		Boundary_Filling( x, y+1, fillColor, boundaryColor,hdc);
	}
}
//------------------------------------------------------
void Draw_Rec(Point a,Point b,Point c,HDC hdc,COLORREF C)
{
		DDA(a.x,a.y,b.x,b.y,C,hdc);
		DDA(b.x,b.y,c.x,c.y,C,hdc);
		DDA(a.x,a.y,c.x,c.y,C,hdc);
}
//---------------------------------
void Scaling_animat(float Sx,float Sy,HDC hdc,COLORREF C1)
{
		Point a(650,350),b(600,440), c(700,440);
		Draw_Rec(a,b,c,hdc,C1);
		Scal_Vector A,B,C;
		for(int i=0;i&lt;=10;i++)
		{
		A=scaling(Sx,Sy,a.x,a.y);
		B=scaling(Sx,Sy,b.x,b.y);
		C=scaling(Sx,Sy,c.x,c.y);
		Point AA(A.elm[0],A.elm[1]);
		Point BB(B.elm[0],B.elm[1]);
		Point CC(C.elm[0],C.elm[1]);
		Sleep(250);
		Draw_Rec(AA,BB,CC,hdc,C1);
		Sx-=.01;
		Sy-=.01;
		a.x=A.elm[0];a.y=A.elm[1];
		b.x=B.elm[0];b.y=B.elm[1];
		c.x=C.elm[0];c.y=C.elm[1];
		}
}
void Fan(HDC hdc,COLORREF C2)
{
		float O=10*3.14/180;//rotate angle
		float O2=120*3.14/180;//angle between=60,,Or =120
		float h=200,k=200;
		Point top(h,k);
		//Triangle  1
		Point P1(h+20,k+100);
		Point P2(h,k+100);
		Vector V1,V2;
		Draw_Rec(top,P1,P2,hdc,C2);
		//Triangle  2
		Vector V3=Rotate(O2,P1.x,P1.y);
		Vector V4=Rotate(O2,P2.x,P2.y);
		Point P3(V3.elm[0],V3.elm[1]);
		Point P4(V4.elm[0],V4.elm[1]);
		Draw_Rec(top,P3,P4,hdc,C2);
		
		//Triangle  3
		Vector V5=Rotate(O2,P3.x,P3.y);
		Vector V6=Rotate(O2,P4.x,P4.y);
		Point P5(V5.elm[0],V5.elm[1]);
		Point P6(V6.elm[0],V6.elm[1]);
		Draw_Rec(top,P5,P6,hdc,C2);
/*__________________________________________________________________________
__________________________________________________________________________*/	
		int i=1;
	COLORREF GRND=GetPixel(hdc,0,0);
	while(i&lt;50)
		{
		Sleep(100);
			//draw with ground
			Draw_Rec(top,P1,P2,hdc,GRND);
			Draw_Rec(top,P3,P4,hdc,GRND);
			Draw_Rec(top,P5,P6,hdc,GRND);
			//tri 1
			V1=Rotate(O,P1.x,P1.y);
			V2=Rotate(O,P2.x,P2.y);
			P1.x=V1.elm[0];P1.y=V1.elm[1];
			P2.x=V2.elm[0];P2.y=V2.elm[1];
			//tri 2
			V3=Rotate(O,P3.x,P3.y);
			V4=Rotate(O,P4.x,P4.y);
			P3.x=V3.elm[0];P3.y=V3.elm[1];
			P4.x=V4.elm[0];P4.y=V4.elm[1];
			//tri 3
			V5=Rotate(O,P5.x,P5.y);
			V6=Rotate(O,P6.x,P6.y);
			P5.x=V5.elm[0];P5.y=V5.elm[1];
			P6.x=V6.elm[0];P6.y=V6.elm[1];
			//draw next triangles
			Draw_Rec(top,P1,P2,hdc,RGB(P1.x+P2.x,P2.x+P1.y,0) );
			Draw_Rec(top,P3,P4,hdc,RGB(P3.x+P4.x,P3.x+P4.y,0) );
			Draw_Rec(top,P5,P6,hdc,RGB(P5.x+P6.x,P5.x+P6.y,0) );

			i++;
		}
}
//***********************************************************************/
//***********************************************************************/
void xySystem(HDC hdc,COLORREF C1,COLORREF C2)
	{
	float dx=100,dy=100;
	//original points
	Point	P1(320,100),P2(315,105),P3(325,395),P4(150,240),
			 P5(500,400),P6(155,235),P7(495,245);

// coordinate sys
		DDA_Line(P1.x,P1.y,P1.x,P5.y,C1,hdc);
		
		DDA_Line(P2.x,P2.y,P1.x,P1.y,C1,hdc);
		DDA_Line(P1.x,P1.y,P3.x,P2.y,C1,hdc);

		DDA_Line(P2.x,P3.y,P1.x,P5.y,C1,hdc);
		DDA_Line(P1.x,P5.y,P3.x,P3.y,C1,hdc);

		DDA_Line(P4.x,P4.y,P5.x,P4.y,C1,hdc);

		DDA_Line(P4.x,P4.y,P6.x,P6.y,C1,hdc);
		DDA_Line(P4.x,P4.y,P6.x,P7.y,C1,hdc);

		DDA_Line(P5.x,P4.y,P7.x,P6.y,C1,hdc);
		DDA_Line(P5.x,P4.y,P7.x,P7.y,C1,hdc);
		//after translation
		Vector V1,V2,V3,V4,V5,V6,V7;
		V1=translation(P1.x,P1.y,dx,dy);
		V2=translation(P2.x,P2.y,dx,dy);
		V3=translation(P3.x,P3.y,dx,dy);
		V4=translation(P4.x,P4.y,dx,dy);
		V5=translation(P5.x,P5.y,dx,dy);
		V6=translation(P6.x,P6.y,dx,dy);
		V7=translation(P7.x,P7.y,dx,dy);
///_______________________________________________________________________

		Dashed_line(V1.elm[0],V1.elm[1],V1.elm[0],V5.elm[1],1,C2,hdc);
		
		Dashed_line(V2.elm[0],V2.elm[1],V1.elm[0],V1.elm[1],1,C2,hdc);
		Dashed_line(V1.elm[0],V1.elm[1],V3.elm[0],V2.elm[1],1,C2,hdc);

		Dashed_line(V2.elm[0],V3.elm[1],V1.elm[0],V5.elm[1],1,C2,hdc);
		Dashed_line(V1.elm[0],V5.elm[1],V3.elm[0],V3.elm[1],1,C2,hdc);

		Dashed_line(V4.elm[0],V4.elm[1],V5.elm[0],V4.elm[1],1,C2,hdc);

		Dashed_line(V4.elm[0],V4.elm[1],V6.elm[0],V6.elm[1],1,C2,hdc);
		Dashed_line(V4.elm[0],V4.elm[1],V6.elm[0],V7.elm[1],1,C2,hdc);

		Dashed_line(V5.elm[0],V4.elm[1],V7.elm[0],V6.elm[1],1,C2,hdc);
		Dashed_line(V5.elm[0],V4.elm[1],V7.elm[0],V7.elm[1],1,C2,hdc);

	}
//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 


Line.h
---------
/////////
---------

void DDA_Line(float x1, float y1, float x2, float y2, COLORREF col,HDC hdc)
{
	float xBegin  =  x1;
	float xFinal  =  x2;
	float yBegin  =  y1;
	float yFinal  =  y2;
	float slope = (y2 - y1) / (x2 - x1);
	float slopeInverse  =  1 / slope;

	if(x1&gt;x2 &amp;&amp; y1&gt;y2)
	{
		xBegin  =  x2;
	    xFinal  =  x1;
		yBegin  =  y2;
	    yFinal  =  y1;
	}
	int x = int(xBegin);
	int y = int(yBegin);

	// if the line is parallel to the y coordinate
	if((xBegin - xFinal) == 0)
		if(yBegin &lt; yFinal)	// and y starting point greater than y end
			while(y &lt;= yFinal)
			{
				SetPixel(hdc, x, y, col);
				y ++;	// increment y
			}
		else
			while(y &gt;= yFinal)
			{
				SetPixel(hdc, x, y, col);
				y --;	// decrement y
			}
	// if the line is parallel to the x coordinate
	else
		if((yBegin - yFinal) == 0)
			if(xBegin &lt; xFinal) // and x starting point greater than x end
				while(x &lt;= xFinal)
				{
					SetPixel(hdc, x, y, col);
					x ++;
				}
			else
				while(x &gt;= xFinal)
				{
					SetPixel(hdc, x, y, col);
					x --;
				}
	else
		if(slope &gt;= 1 || slope &lt;= -1) // new case
		{
			if(yFinal &gt; yBegin) // from begin to end
				while(y &lt;= yFinal)
				{
					x = int(xBegin + 0.5);
					xBegin = xBegin + slopeInverse;
					SetPixel(hdc, x, y, col);
					y ++;
				}
			else		// from end to begin
				while(y &gt;= yFinal)
				{
					x = int(xBegin + 0.5);
					xBegin = xBegin - slopeInverse;
					SetPixel(hdc, x, y, col);
					y --;
				}
		}
	else
		if(slopeInverse &gt;= 1 || slopeInverse &lt;= -1) // new case
		{
			if(xFinal &gt; xBegin)	// from begin to end
				while(x &lt;= xFinal)
				{
					y = int(yBegin + 0.5);
					yBegin = yBegin + slope;
					SetPixel(hdc, x, y, col);
					x ++;
				}
			else		// from end to begin
				while(x &gt;= xFinal)
				{
					y = int(yBegin + 0.5);
					yBegin = yBegin - slope;
					SetPixel(hdc, x, y, col);
					x --;
				}
		}//if
}
/*&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;*/									 
void DDA(const int x_1,const int y_1,const int x_2,const int y_2,COLORREF color ,HDC hdc)
    {
  //     int color=getcolor( );

       int x1=x_1;
       int y1=y_1;

       int x2=x_2;
       int y2=y_2;
       if(x_1&gt;x_2)
	  {
	     x1=x_2;
	     y1=y_2;

	     x2=x_1;
	     y2=y_1;
	  }

       int dx=abs(x2-x1);
       int dy=abs(y2-y1);
       int inc_dec=((y2&gt;=y1)?1:-1);

       if(dx&gt;dy)
	  {
	     int two_dy=(2*dy);
	     int two_dy_dx=(2*(dy-dx));
	     int p=((2*dy)-dx);

	     int x=x1;
	     int y=y1;

	     SetPixel(hdc, x, y, color);

	     while(x&lt;x2)
		{
		   x++;

		   if(p&lt;0)
		      p+=two_dy;

		   else
		      {
			 y+=inc_dec;
			 p+=two_dy_dx;
		      }

		   SetPixel(hdc, x, y, color);
		}
	  }

       else
	  {
	     int two_dx=(2*dx);
	     int two_dx_dy=(2*(dx-dy));
	     int p=((2*dx)-dy);

	     int x=x1;
	     int y=y1;

	     SetPixel(hdc, x, y, color);

	     while(y!=y2)
		{
		   y+=inc_dec;

		   if(p&lt;0)
		      p+=two_dx;

		   else
		      {
			 x++;
			 p+=two_dx_dy;
		      }

		   SetPixel(hdc, x, y, color);
		}
	  }
    }
//***********************************************************************
void Dashed_line(const float x_1,const float y_1,const float x_2,
					  const float y_2,const float line_type,COLORREF color,HDC hdc)
    {
       int count=0;
       int x1=x_1;
       int y1=y_1;

       int x2=x_2;
       int y2=y_2;

       if(x_1&gt;x_2)
	  {
	     x1=x_2;
	     y1=y_2;

	     x2=x_1;
	     y2=y_1;
	  }

       int dx=abs(x2-x1);
       int dy=abs(y2-y1);
       int inc_dec=((y2&gt;=y1)?1:-1);

       if(dx&gt;dy)
	  {
	     int two_dy=(2*dy);
	     int two_dy_dx=(2*(dy-dx));
	     int p=((2*dy)-dx);

	     int x=x1;
	     int y=y1;
		 SetPixel(hdc,x,y,color);
	    while(x&lt;x2)
		{
		   x++;

		   if(p&lt;0)
		      p+=two_dy;

		   else
		      {
			 y+=inc_dec;
			 p+=two_dy_dx;
		      }

		   if((count%2)!=0 &amp;&amp; line_type==0)
			  SetPixel(hdc,x,y,color);
		   else if((count%5)!=4 &amp;&amp; line_type==1)
		      SetPixel(hdc,x,y,color);

		   else if((count%10)!=8 &amp;&amp; (count%10)!=9 &amp;&amp; line_type==2)
			   SetPixel(hdc,x,y,color);

		   else if((count%20)!=18 &amp;&amp; (count%20)!=19 &amp;&amp; line_type==3)
		      SetPixel(hdc,x,y,color);

		   else if((count%12)!=7 &amp;&amp; (count%12)!=8 &amp;&amp;
			    (count%12)!=10 &amp;&amp; (count%12)!=11 &amp;&amp; line_type==4)
		      SetPixel(hdc,x,y,color);

		   count++;
		}
	  }

       else
	  {
	     int two_dx=(2*dx);
	     int two_dx_dy=(2*(dx-dy));
	     int p=((2*dx)-dy);

	     int x=x1;
	     int y=y1;

	     SetPixel(hdc,x,y,color);

	     while(y!=y2)
		{
		   y+=inc_dec;

		   if(p&lt;0)
		      p+=two_dx;

		   else
		      {
			 x++;
			 p+=two_dx_dy;
		      }

		   if((count%2)!=0 &amp;&amp; line_type==0)
		     SetPixel(hdc,x,y,color);
		   else if((count%5)!=4 &amp;&amp; line_type==1)
		      SetPixel(hdc,x,y,color);
		   else if((count%10)!=8 &amp;&amp; (count%10)!=9 &amp;&amp; line_type==2)
		     SetPixel(hdc,x,y,color);

		   else if((count%20)!=18 &amp;&amp; (count%20)!=19 &amp;&amp; line_type==3)
		     SetPixel(hdc,x,y,color);

		   else if((count%12)!=7 &amp;&amp; (count%12)!=8 &amp;&amp;
			    (count%12)!=10 &amp;&amp; (count%12)!=11 &amp;&amp; line_type==4)
		      SetPixel(hdc,x,y,color);

		   count++;
		}
	  }
    }




ellipse_circle.h
------------------
///////////////////
------------------

void plot_fourPoints(double x,double y,double h,double k,COLORREF color,HDC hdc)
{
		SetPixel(hdc, x+h , y+k,  color);
		SetPixel(hdc, -x+h, -y+k, color);
		
		SetPixel(hdc, x+h, -y+k,  color);
		SetPixel(hdc, -x+h, y+k,  color);

}
/*********************************************************************
***************    Polynomial  Algorthim          ********************/
void polynomial_ellipse( double a,double b,COLORREF color,HDC hdc )
{
	int h=500,k=120;			//		ellipse center
	double x=0.0,X_end=a;		// a    major axis,,, b mainor axis
	while(x&lt;=X_end)
	{
		double y=b*( sqrt( 1- (x*x)/(a*a)  ) );
		plot_fourPoints(x,y,h,k,color,hdc);

		x+=.001;
	}//end loop
}
/*________________________________________________________________________
				Circle Using Brthenham Algorthim
__________________________________________________________________________
__________________________________________________________________________*/
void Circle(HDC dc ,int r )
{
	int x=0;
	int y=r;
	int h=200,k=200;//circle center
	int d=3-2*y;
	COLORREF color1=RGB(0,0,255),color2=RGB(255,0,0),
			 color3=RGB(0,255,0),color4=RGB(255,0,255);

	while(x&lt;y)
	{
		SetPixel(dc,x+h,y+k,color1);
		SetPixel(dc,y+h,x+k,color2);		
		SetPixel(dc,-y+h,x+k,color3);
		SetPixel(dc,-x+h,y+k,color4);

		SetPixel(dc,-x+h,-y+k,color1);
		SetPixel(dc,-y+h,-x+k,color2);
		SetPixel(dc,y+h,-x+k,color3);
		SetPixel(dc,x+h,-y+k,color4);
		if(d&lt;0)
		{
			d+=4*x+6;
			x++;
		}
		else
		{
			d=d+4*(x-y)+10;
			x++;
			y--;
		}
	}
}
//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
void MidPoint_ellipse(HDC hdc, int a, int b, COLORREF col)
{
	int x = 0;
	int y = b;
	int aa = a*a;
	int bb = b*b;
	int aa2= aa*2;
	int bb2= bb*2;
	int h=500,k=120;
	int fx=0;
	int fy=aa2*b;
	
	int p = int (bb - aa*b + 0.25*aa) ;

	while(fx &lt; fy)
			{
		plot_fourPoints(x, y , h, k,col, hdc);

				fx=fx+bb2;

				if(p&lt;0)
					p = p + fx + bb;
				else
				{
					fy = fy - aa2;

					p = p + fx + bb - fy;
					y--;
				}
				x++;
			}

	p = int (bb*(x+0.5)*(x+0.5)+aa*(y-1)*(y-1)-aa*bb);

	while(y&gt;=0)
			{
				SetPixel(hdc, x+h , y+k , col);

				SetPixel(hdc, -x+h , y+k , col);

				SetPixel(hdc, -x+h , -y+k , col);

				SetPixel(hdc, x+h , -y+k , col);

				fy = fy - aa2;

				if(p&gt;=0)
					p = p - fy + aa;
				else
				{
					fx = fx + bb2;

					p = p + fx + aa - fy;
					x++;
				}
				y--;
			}
}




Liagn_Cliping.h
----------------
//////////////////
-----------------

//#include"Line.h"
//float X_min=210, X_max=500,Y_min=150, Y_max=430;
float X_min=50, X_max=700,Y_min=50, Y_max=450;
struct Interserct
{
	float Xi,Yi;
};

void Draw_Window(float x1, float y1, float x2, float y2,COLORREF col,HDC hdc)
{
	DDA(x1,y1,x1,y2,col,hdc);
	DDA(x1,y1,x2,y1,col,hdc);
	DDA(x2,y2,x1,y2,col,hdc);
	DDA(x2,y2,x2,y1,col,hdc);
}
float MAX(float x,float y)
{
	return x&gt;y?x:y;
}

float MIN(float x,float y)
{
	return x&lt;y?x:y;
}
//====================  Liagn Barsky		==============================
//========================================================================
void Liagn_Barsky(float x1, float y1, float x2, float y2,COLORREF Col,HDC hdc)
{
	COLORREF C=RGB(255,0,0);
	float dx=x2-x1,dy=y2-y1;
	float P[4],Q[4];
	float R[4],U1=0,U2=1;
	Interserct  end_P1 , end_P2;//tow intersected points
	//intialize all variables
	
	P[0]=-dx;		Q[0]=x1-X_min;
	P[1]=dx	;		Q[1]=X_max-x1;
	P[2]=-dy;		Q[2]=y1-Y_min;
	P[3]=dy ;		Q[3]=Y_max-y1;

	for(int i=0;i&lt;4;i++)
	{
		if( P[i]==0&amp;&amp;Q[i]&lt;0 )//line completly out side window
				return;	
		if( P[i]&lt;0 )
		{
			R[i]=Q[i]/P[i];
			U1=MAX(R[i],MAX(0,U1));
		}

		else if( P[i]&gt;=0 )
		{
			R[i]=Q[i]/P[i];
			U2=MIN(R[i],MIN(1,U2));
		}
	}//end for
	if( U1&gt;U2 )
		return;
//calculate end points
		end_P1.Xi=x1+dx*U1;				end_P1.Yi=y1+dy*U1;
		end_P2.Xi=x1+dx*U2;				end_P2.Yi=y1+dy*U2;


//DDA_ALGORITHM(x1,y1,end_P1.Xi,end_P1.Yi,C,hdc);
//DDA_ALGORITHM(end_P2.Xi,end_P2.Yi,x2,y2,C,hdc);

DDA(  end_P1.Xi, end_P1.Yi,
				end_P2.Xi,end_P2.Yi,	Col, hdc);

}


</TEXTAREA> <BR>
<CENTER><IMG 
style="BORDER-RIGHT: #0066cf 1px solid; BORDER-TOP: #0066cf 1px solid; BORDER-LEFT: #0066cf 1px solid; WIDTH: 350px; BORDER-BOTTOM: #0066cf 1px solid; HEIGHT: 300px" 
src="130_files/project.gif"> </CENTER><!-- Search Google -->
<CENTER>
<FORM action=http://www.google.com/custom method=get target=_top>
<TABLE bgColor=#ffffff>
  <TBODY>
  <TR>
    <TD vAlign=top noWrap align=left height=32><A 
      href="http://www.google.com/"><IMG alt=Google 
      src="130_files/Logo_25wht.gif" align=middle border=0></IMG></A> <LABEL 
      style="DISPLAY: none" for=sbi>Enter your search terms</LABEL> <INPUT 
      id=sbi maxLength=255 size=40 name=q></INPUT> <LABEL style="DISPLAY: none" 
      for=sbb>Submit search form</LABEL> <INPUT id=sbb type=submit value=Search name=sa></INPUT> <INPUT type=hidden 
      value=pub-9653171024150495 name=client></INPUT> <INPUT type=hidden value=1 
      name=forid></INPUT> <INPUT type=hidden value=ISO-8859-1 name=ie></INPUT> 
      <INPUT type=hidden value=ISO-8859-1 name=oe></INPUT> <INPUT type=hidden 
      value=active name=safe></INPUT> <INPUT type=hidden 
      value=GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:336699;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;FORID:1 
      name=cof></INPUT> <INPUT type=hidden value=en name=hl></INPUT> 
  </TD></TR></TBODY></TABLE></FORM></CENTER><!-- Search Google -->
<H3><A 
href="http://www2.webng.com/amrlearn/Index.html">Home</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www2.webng.com/amrlearn/127.html">Previous</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www2.webng.com/amrlearn/82.html">Next</A></H3></DIV></BODY></HTML>
