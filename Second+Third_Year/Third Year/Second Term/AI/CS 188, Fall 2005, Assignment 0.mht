From: <Saved by Windows Internet Explorer 7>
Subject: CS 188, Fall 2005, Assignment 0
Date: Mon, 12 Feb 2007 20:08:37 +0200
MIME-Version: 1.0
Content-Type: text/html;
	charset="windows-1256"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.cs.berkeley.edu/~russell/classes/cs188/f05/assignments/a0/a0.html
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2900.2962

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>CS 188, Fall 2005, Assignment 0</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Dwindows-1256">
<META content=3D"MSHTML 6.00.5730.11" name=3DGENERATOR></HEAD>
<BODY bgColor=3D#f7f5ea>
<HR>

<H2>CS 188, Fall 2005, Introduction to Artificial Intelligence =
<BR>Assignment 0,=20
due 9/8, total value 1% of grade</H2>
<HR>
<BR><B>To be done individually</B><BR>
<P>People entering CS188 vary widely in their Lisp experience: this =
assignment=20
should serve as a refresher and an opportunity to become more familiar =
with=20
Common Lisp in particular.<BR>
<P>Grading on this assignment is binary: if you make an honest effort at =
most of=20
the questions you will get 100%, otherwise 0%. As with any programming=20
assignment, include with each answer a transcript showing that the code =
works on=20
a few different inputs. Submit your solution using the <TT>submit</TT> =
program=20
from an instructional (named or class) account, as described <A=20
href=3D"http://www.cs.berkeley.edu/~russell/classes/cs188/f05/submit.html=
">here</A>.=20
The name for the assignment is <TT>a0</TT> and your solution file should =
be=20
called <TT>a0.lisp</TT>. Your file should be loadable into lisp and =
should=20
include explanations and output traces (as needed) in portions commented =
with=20
semicolons. <BR>
<P>You may find the <A=20
href=3D"http://www.cs.berkeley.edu/~russell/classes/cs188/f05/assignments=
/a0/lisp-notes.html"><B>Notes=20
on Lisp</B></A> useful as well as the <A=20
href=3D"http://www.cs.berkeley.edu/~russell/classes/cs188/f05/assignments=
/a0/lisp-tutorial.html">Tutorial=20
on how to use Lisp, emacs, and the AIMA code</A>.=20
<P>Please try to comment your code and use, meaningful variable =
names.<BR>
<OL>
  <LI>Exponentiation<BR>Write a recursive function <TT>(two-to-the =
x)</TT> which=20
  takes a single non-negative integer parameter <I>x</I> and returns=20
  2<I><SUP>x</SUP></I>. (This can be done in logarithmic time.) <BR><BR>
  <LI>Write a LISP function <TT>(count-trees n)</TT> which returns the =
number of=20
  distinct strictly binary trees with <I>n</I> leaves. A strictly binary =
tree is=20
  one in which every node other than a leaf has exactly two children. A =
leaf has=20
  no children. There is 1 strictly binary tree with 1 leaf (just a =
single node=20
  tree), 1 strictly binary tree with 2 leaves, 2 distinct strictly =
binary trees=20
  with 3 leaves, and 5 distinct strictly binary trees with exactly 4 =
leaves.=20
  (<TT>count-trees n</TT>) can be implemented fairly easily using =
recursion.=20
  Test your program for <I>n</I> =3D 1 through 10. [<I>Hint</I>: Suppose =
a tree=20
  with <I>n</I> leaves has <I>a</I> leaves in its left subtree and =
<I>b</I>=20
  leaves in its right subtree, where <I>a</I>+<I>b</I>=3D<I>n</I>; how =
many such=20
  trees are there?]<BR>Optional: measure the runtime as a function of =
<I>n</I>=20
  and find a way to speed it up by caching partial results.<BR><BR>
  <LI>Symbolic differentiation<BR>One important AI application area is =
symbolic=20
  mathematics, particularly calculus. For this problem, you will =
construct a=20
  function <TT>deriv</TT> which differentiates simple, single-variable=20
  mathematical expressions. The function takes two arguments. The first =
is a=20
  mathematical expression in standard LISP syntax, containing numbers, =
atoms=20
  (representing constants and variables) and the functions +,-,*,/,expt. =
(Note=20
  that +, -, and * can be applied to any number of arguments. You need =
not=20
  handle * applied to more than two arguments unless you want brownie =
points.)=20
  The second is the name of the variable with respect to which to =
differentiate.=20
  Other symbols in the expression are treated as constants. The rules of =

  differentiation are as follows (where <I>u</I> and <I>v</I> are =
arbitrary=20
  expressions):<BR><BR><I>u =3D </I>constant<I> implies du/dx =3D=20
  </I>0<BR><I>dx/dx=3D</I>1<BR><I>d(u+v)/dx =3D du/dx + dv/dx; d(u-v)/dx =
=3D du/dx -=20
  dv/dx<BR>d(uv)/dx =3D udv/dx + vdu/dx<BR>d(u/v)/dx =3D (vdu/dx -=20
  udv/dx)/v</I><SUP>2<BR></SUP><I>v =3D </I>constant<I> implies=20
  d(u<SUP>v</SUP>)/dx =3D (du/dx)vu<SUP>(v-</SUP></I><SUP>1<I>)=20
  <BR></I></SUP><I>d(e<SUP>u</SUP>)/dx =3D =
(du/dx)e<SUP>u<BR><BR></SUP></I>Test=20
  your function on some interesting inputs. Add more rules (e.g., for =
trig=20
  functions) if you wish. For extra brownie points, you can write a =
simplifier=20
  to reduce the resulting expressions to their simplest form. For =
example, <I>0=20
  * u</I> simplifies to <I>0</I> and so on.<BR><BR>
  <LI>List recursion<BR>Write the following =
functions:<BR>(<TT>last-element=20
  l</TT>) returns the last element of <TT>l</TT>;<BR>(<TT>all-but-last =
l</TT>)=20
  returns all but the last element;<BR>(<TT>my-reverse l</TT>) returns =
the=20
  reversed list. (Should run in O(n) time.)=20
  <LI>Powerset<BR>A standard mathematical set function is =
<TT>powerset</TT>,=20
  which computes the set of all subsets of a set. For example, <PRE>   =
&gt;    (powerset '(a b))
   (nil (a) (b) (a b))
</PRE>Implement this as a recursive function. It may require other =
subsidiary=20
  functions. <BR><BR>
  <LI>Data types<BR>(a) Write <TT>defstructs</TT>s for points and line =
segments=20
  in two dimensions.<BR>(b) Write a function (<TT>distance p1 p2</TT>) =
that=20
  returns the distance between two points.<BR>(c) Write a function =
(<TT>midpoint=20
  l</TT>) that returns the midpoint of a line segment.<BR>(d) Write a =
function=20
  (<TT>intersectp l1 l2</TT>) that decides if two line segments =
intersect.=20
  [Hint: the location of an arbitrary point on AB can be written as vA + =
(1-v)B;=20
  a point on CD is wC +(1-w)D; the lines cross where these are equal. =
This gives=20
  two equations (equating both x and y parts) for v and w. Solve these =
to find=20
  the intersection point, if any. Then you need to check that the =
intersection=20
  is actually on both segments - this can be determined by looking at =
the values=20
  of v and w.]<BR>(e) A <I>polygon</I> can be defined by a list of =
points, where=20
  each point is assumed to be connected to the next. (You may wish to =
use the=20
  <TT>:type</TT> option to <TT>defstruct</TT> to make the structure =
itself be a=20
  list.) Define methods for calculating the <TT>area</TT> of a polygon. =
Begin=20
  with subtypes such as rectangle, square, triangle, regular polygon. =
Formulas=20
  for these can be found on the web. Optionally, you can provide a =
method that=20
  works for any polygon. You can assume that the list of points supplied =
to=20
  build any particular shape does in fact describe such a shape; for =
extra=20
  brownie points, include checks in the constructor functions. <BR>(f)=20
  (Optional) A <I>scene</I> is a list of polygons. Write a method =
<TT>(visiblep=20
  scene p1 p2)</TT> that checks if one point is visible from another in =
a scene=20
  (that is, there is a straight line from one to the other not =
intersecting any=20
  polygon). Note that one vertex on a polygon should be visible from its =

  immediate neighbors on the same polygon.<BR>(g) (Optional) Create a =
scene full=20
  of polygons by instantiating your data types, using the coordinate =
data in <A=20
  =
href=3D"http://www.cs.berkeley.edu/~russell/classes/cs188/f05/assignments=
/a0/geometric-scene.data">here</A>.=20
  Check to make sure that your <TT>visiblep</TT> predicate =
works.<BR><BR>
  <LI>Load the AIMA (textbook) code in <TT>~cs188/code-2e-188</TT> on =
the=20
  instructional machines (web-accessible <A=20
  =
href=3D"http://www-inst.eecs.berkeley.edu/~cs188/code-2e-188">here</A>). =
Make=20
  sure it works by compiling the utilities and agents subsystems (do=20
  <TT>(aima-compile 'utilities)</TT> and <TT>(aima-compile =
'agents)</TT>) and=20
  running <TT>(test 'utilities)</TT> and <TT>(test 'agents)</TT>. If you =
want,=20
  you can try to write a better vacuum world agent. More information =
(somewhat=20
  outdated compared to the current version) on the AIMA code is =
available: see=20
  the <A=20
  =
href=3D"http://www.cs.berkeley.edu/~russell/code/doc/overview.html">overv=
iew</A>=20
  and the <A=20
  =
href=3D"http://www.cs.berkeley.edu/~russell/code/doc/user.html">instructi=
ons on=20
  how to use the code</A>. </LI></OL></BODY></HTML>
