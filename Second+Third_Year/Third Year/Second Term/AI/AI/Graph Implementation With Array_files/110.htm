<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0039)http://www2.webng.com/amrlearn/110.html -->
<HTML><HEAD><TITLE>Graph Implementation With Array</TITLE><LINK 
href="110_files/stylesheet.css" type=text/css rel=stylesheet>
<META http-equiv=Content-Type content="text/html; charset=UTF-8">
<META content="Graph Implementation With Array Graph Implementation With Array " 
name=description>
<META 
content="C++, Graph Implementation With Array, Graph, Implementation, With, Array " 
name=keywords>
<META content="Copyright 2007 Amr Saber" name=copyright>
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY>
<CENTER>
<DIV id=header>
<SCRIPT type=text/javascript><!--
google_ad_client = "pub-9653171024150495";
google_alternate_color = "C3D9FF";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text";
//2007-02-02: header
google_ad_channel = "7161698987";
//--></SCRIPT>

<SCRIPT src="110_files/show_ads.js" type=text/javascript>
</SCRIPT>
</DIV></CENTER>
<DIV id=index>
<H3>Goooooooogle</H3>
<SCRIPT type=text/javascript><!--
google_ad_client = "pub-9653171024150495";
google_alternate_color = "C3D9FF";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_ad_type = "text";
//2007-02-02: header, right
google_ad_channel = "7161698987+2593520185";
//--></SCRIPT>

<SCRIPT src="110_files/show_ads.js" type=text/javascript>
</SCRIPT>
</DIV>
<DIV id=index2>
<H3>Goooooooogle</H3>
<SCRIPT type=text/javascript><!--
google_ad_client = "pub-9653171024150495";
google_alternate_color = "C3D9FF";
google_ad_width = 120;
google_ad_height = 600;
google_ad_format = "120x600_as";
google_ad_type = "text";
google_ad_channel = "";
//--></SCRIPT>

<SCRIPT src="110_files/show_ads.js" type=text/javascript>
</SCRIPT>
</DIV>
<DIV id=content>
<H3>Graph Implementation With Array</H3>
<P></P><TEXTAREA>
/*				Graph implementation with array					*/
#include&lt;iostream.h&gt;
#include&lt;fstream.h&gt;
typedef  int key_type;
const int max=100;
#include&lt;process.h&gt;
struct elm_type
{
	char name[10];
	key_type key;
	bool proc;
	/*void init()
	{
		proc=false;
	}*/
	void showdata()
	{
		cout&lt;&lt;"\t"&lt;&lt;name&lt;&lt;"\t"&lt;&lt;key&lt;&lt;"\t"&lt;&lt;proc&lt;&lt;endl;
	
	}
	void getdata()
	{
		cout&lt;&lt;"\tenter node name: ";
		cin&gt;&gt;name;
		cout&lt;&lt;"\tenter key value: ";
		cin&gt;&gt;key;
	}
};
//==================================================================
//================  Queue Data Structure         ===================
class Queue
{
private:
	int front,rare,count;
	key_type data[max];
public:
	Queue()
	{
		count=0;
		front=1;
		rare=0 ;
	}
	~Queue()
	{
		count=0;
	}
	bool is_empty()
	{
		return count==0 ?true:false;
	}

	bool is_full()
	{
		return count==max ?true:false;
	}
	//	Queue	Operations
void inQueue( key_type K)
{
	if( is_full() )
	{
		cerr&lt;&lt;"Queue is Full \n\n";	exit(0);
	}
	rare=(rare+1)%max;
	data[rare]=K;
	count++;
}
key_type  deQueue( )
{
	if( is_empty() )
	{
		cerr&lt;&lt;"Queue is Empty";	exit(0);
	}
	key_type K=data[front];
	front=(front+1)%max;
	count--;
	return K;
}

};//end Queue
//==============================================================
class stack
{
private:
	int top;
	elm_type data[100];
public:
	stack()
	{
      top=0;
	}
	//////////////////////////////////////////////////////////
	bool stackIsEmpty()
	{
		if(top==0)
			return true;
		else 
			return false;
	}
	//////////////////////////////////////////////////////////
	bool stackIsFull()
	{
		return (top==max?true:false);
	}
	//////////////////////////////////////////////////////////
	void push(int  d,int  d2)
	{
		if (stackIsFull())
		{
			cout&lt;&lt;"stack is full"&lt;&lt;endl;
			return;
		}
		elm_type e;
		e.key=d;
		e.name=d2;
		data[top++]=e;
	}
    //////////////////////////////////////////////////////////
	elm_type pop()
	{
		elm_type d=data[--top];
		return d;
	}
};
/*********************************************************************
-_-_-_-_-_-_-_-_-_-_ Graph Data Structure  -_-_-_-_-_-_-_-_-_-_-_-_-_-
**********************************************************************/
class graph
{
private:
	//Node Content
	elm_type nodes[max];		//node
	bool edges[max][max];		//relation
	int count;

public:
	graph()
	{	count=0;	}

	~graph()
	{	count=0;	}
	void processed(key_type);
	bool unprocessed();
	bool unprocessed1(key_type);
//\\//\\//\\//\\//\\//\\/____________
	bool graph_isEmpty()
	{
		return count==0 ?true:false;
	}
//\\//\\//\\//\\//\\//\\/____________
	bool graph_isFull()
	{
		return count==max ?true:false;
	}
//\\//\\//\\//\\//\\//\\/____________
	bool key_found(key_type K)
	{
		for(int i=0;i&lt;count;i++)
			if(nodes[i].key==K)
				return true;
				return false;
	}
//\\//\\//\\//\\//\\//\\/____________
	int find_node(key_type K)
	{
		for(int i=0;i&lt;count;i++)
			if( nodes[i].key==K )
				return i;			//node  index  in garph 
				return -1;
	}
/*********************************************************************
					Garph Main Operations
*********************\\//\\//\\//\\//\\//\\/**************************/
	void insert_node(elm_type new_node)
	{
		if( graph_isFull() )
		{
			cerr&lt;&lt;"\tcan not insert new node..graph is Full\n\n";
			return;
		}
//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
		if( key_found( new_node.key ) )
		{
			cerr&lt;&lt;"doublecated key value"&lt;&lt;endl;
			return;
		}
//&gt;&gt;&gt;&gt;&gt;&gt;	Insertion
		nodes[count]=new_node;
		for(int i=0;i&lt;=count;i++)
		{
			edges[i][count]=false;	//colume
			edges[count][i]=false;	//row
		}
		count++;//new node add in graph
		cout&lt;&lt;"new node add in graph correctly\n";
	}
/*____________________________________________________________________
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;*/
	void delete_node( key_type K )
	{
		if( graph_isEmpty() )
		{
			cerr&lt;&lt;"can not delete  node..graph is empty"&lt;&lt;endl;
			return;
		}
//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
		int indx=find_node( K );
		if(indx==-1)
		{
			cerr&lt;&lt;"there are no node with this key to delete"&lt;&lt;endl;
			return;
		}
//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  Deletion
		count --;
		if(indx&lt;count)		//not the last node in structure
		nodes[indx]=nodes[count];
	
		for(int i=0;i&lt;=count;i++)
		{
			edges[indx][count]=edges[i][count];		//colume
			edges[count][indx]=edges[i][count];		//row
		}
		
		//not enough the midel element is changed 
		edges[indx][indx]=edges[count][count];
		cout&lt;&lt;"\tDelete node Opertation Completed Correctly..!\n\n";
	}//end delete

/*&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;*/
	void insert_edge( key_type K1, key_type K2 )
	{
	int	indx1=find_node( K1 );
	int	indx2=find_node( K2 );
	if( indx1==-1||indx2==-1 )
	{
			cerr&lt;&lt;"\tCan not insert edge..Please Check the Keys\n\n";
			return;
	}
	edges[indx1][indx2]=true;
	edges[indx2][indx1]=true;
	cout&lt;&lt;"Inserting Edge Betwwen "&lt;&lt;K1&lt;&lt;"  and  "&lt;&lt;K2&lt;&lt;" done Correctly\n\n";
	}//end ins edges
/*********************************************************************
&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;*/
void remove_edge( key_type K1, key_type K2 )
	{
	int	indx1=find_node( K1 );
	int	indx2=find_node( K2 );

	if( indx1==-1||indx2==-1 )
	{
			cerr&lt;&lt;"can not remove edge "&lt;&lt;endl;
			return;
	}
	if(edges[indx1][indx2]==0)	
		{cout&lt;&lt;"no edge between this two keys\n";return;}

	//destroy edge between K1 &amp; K2
	edges[indx1][indx2]=false;
	edges[indx2][indx1]=false;
	cout&lt;&lt;"\tRemoving edge Between  "&lt;&lt;K1&lt;&lt;"  and "&lt;&lt;K2&lt;&lt;"  Completed Correctly..!\n\n";
}
/*********************************************************************/
void update_node(elm_type e )
{
	int	indx=find_node( e.key );
	if( indx==-1 )
	{
			cerr&lt;&lt;"Can not update node"&lt;&lt;endl;
			return;
	}//_____

	nodes[indx]=e;
	cout&lt;&lt;"Node withe key= "&lt;&lt;e.key&lt;&lt;"  is updated correctly"&lt;&lt;endl;
}//====
/*&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;*/
void show_graph()
{
	if( graph_isEmpty() )
	{cout&lt;&lt;"graph is empty...no nodes ingraph to show\n\n";return;}
	for( int a=0;a&lt;count;a++)
		nodes[a].showdata();
//**
	cout&lt;&lt;"\tThe Edges Relation Matrix is\n\n";
	for( int i=0;i&lt;count;i++)
	{
		cout&lt;&lt;"\t";
		for( int j=0;j&lt;count;j++)
			cout&lt;&lt;edges[i][j]&lt;&lt;"\t";
				cout&lt;&lt;endl;
	}
}//end show graph
//&gt;&gt;&gt;&gt;&gt;  Graph Application
//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   Search Algorthims  &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
void Processed( key_type K)
{
	int n=key_found(K);
	if(n==-1)
	{
		cerr&lt;&lt;"error can not process\n";exit(0);
	}
	nodes[n].proc=true;
}

key_type UnProc_Adj( key_type K)
{
	int n=key_found( K );
	if(n==-1)
	{
		cerr&lt;&lt;"error can not process\n";exit(0);
	}
	for(int i=0;i&lt;count;i++)//adjecent &amp; unvisted node
		if(edges[n][i]==true &amp;&amp; nodes[i].proc==false )
			return nodes[i].key;
return -1;
}

int getcount()
	   {
		   return count;

	   }
key_type getkey(int i)
	   {
		   return nodes[i].key;
	   }
//===================================
int isadjacent(key_type k1,key_type k2)
	   {
		   int n1=find_node(k1);
		   int n2=find_node(k2);
		   if(n1==-1||n2==-1)
		   {
			   cout&lt;&lt;"\tError Adjacent &lt;Node is Missing&gt;\n";
			   return -1;
		   }
		   if(edges[n1][n2]==0&amp;&amp;edges[n2][n1]==0)
			   return 0;
		   return 1;
	   }

};//end class  .. Graph  .....
//_____________________________________________________________________
bool bridthfirst(graph &amp;g,key_type start,key_type target, Queue &amp; s)
{
	int   n=g.getcount();
	elm_type current,x;
	if(g.find_node(start)&lt;0)
		return false;
	s.inQueue(start);
	g.unprocessed();
	g.processed(start);
	while(!s.is_empty())
	{
		current.key=s.deQueue();
		if(current.key==target)
			return true;
		bool y=false;
		int z=0;
		int i=0;
		while(i&lt;n&amp;&amp;!y)
		{
			x.key=g.getkey(i);
			z=g.isadjacent(current.key,x.key);
			if(z&gt;0 &amp;&amp;g.unprocessed1(x.key))
			{
				s.inQueue(x.key);
				g.processed(x.key);
				y=true;
			}
			else i++;

		}
	}
	return false;
}
//==============================================================
bool depthfirst(graph g,elm_type start,elm_type target,stack&amp; s)
{
	int   n=g.getcount();
	eltype current,x;
	if(g.findnode(start.key)&lt;0)
		return false;
	s.push(start);
	g.unprocessed();
	g.processed(start.key);
	while(!s.stack_is_empty())
	{
		current=s.retrieve();
		if(current.key==target.key)
			return true;
		bool y=false;
		int z=0;
		//for(int i=1;i&lt;n;i++)
		int i=0;
		while(i&lt;n&amp;&amp;!y)
		{
			x.key=g.getkey(i);

			z=g.isadjacent(current.key,x.key);
			if(z&gt;0 &amp;&amp;g.unprocessed1(x.key))
			{
				s.push(x);
				g.processed(x.key);
				y=true;
			}
			else i++;

		}
		if(!y)
		s.pop();
	}
	return false;
}

/*********************************************************************/
void build_graph(graph&amp; g)
{

	elm_type e1, e2;
	e1.proc=false;
	e2.proc=false;
	char* filename = "graph.txt";
	char ch;
	ifstream infile(filename);

	if(!infile)
	{
		cout&lt;&lt;"Error: cannot open file"&lt;&lt;endl;
		exit(0);
	}

	while(infile&gt;&gt;e1.key)
	{
		infile&gt;&gt;e1.name;
		g.insert_node(e1);

		while(infile.get(ch) &amp;&amp; ch != '\n')
		{
			infile&gt;&gt;e2.key;
			if(g.key_found(e2.key))
				g.insert_edge(e1.key, e2.key);
		}
	}
}
/*********************************************************************/
	int showMenu()
		{
						int ch;
					cout&lt;&lt;"\t\t\tGraph Operations \n";
			cout&lt;&lt;"\t\tEnter 1 for Adding New node    \n";
			cout&lt;&lt;"\t\tEnter 2 for Deleting node      \n";
			cout&lt;&lt;"\t\tEnter 3 for Insert new Edge    \n";
			cout&lt;&lt;"\t\tEnter 4 for Remove  edge       \n";	
			cout&lt;&lt;"\t\tEnter 5 for Update node        \n";	
			cout&lt;&lt;"\t\tEnter 6 for Display Graph      \n";
						cout&lt;&lt;"\tEnter Your Chooice:  ";
							cin&gt;&gt;ch;
							return ch;
		}//Menu
/*********************************************************************/
/*____________________________________________________________________
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;							&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;*/
void main()
{
	
	graph G;
	build_graph( G );
	//G.show_graph();
	cout&lt;&lt;"\n\n";
	cout&lt;&lt;Brdth_first(G,3,5)&lt;&lt;endl;

	/*key_type k1 , k2;
	elm_type e1,e2;
	bool flag=true;
	char ch='y';
	while(flag)
	{
		switch( showMenu() )
		{
		case 1:
			e1.getdata();
			g.insert_node( e1 );
			break;
		case 2:
			cout&lt;&lt;"\tEnter key to delete node: ";
			cin&gt;&gt;k1;
			g.delete_node( k1 );
			break;
		case 3:
			cout&lt;&lt;"\tEnter two keys to Insert Edge\n";
			cout&lt;&lt;"\t\tKey 1= ";cin&gt;&gt;k1;
			cout&lt;&lt;"\t\tKey 2= ";cin&gt;&gt;k2;
			g.insert_edge( k1,k2 );
			break;
		case 4:
			cout&lt;&lt;"\tEnter two keys to remove edge\n";
			cout&lt;&lt;"\t\tKey 1= ";cin&gt;&gt;k1;
			cout&lt;&lt;"\t\tKey 2= ";cin&gt;&gt;k2;
			g.remove_edge( k1,k2 );
			break;
		case 5:
			e2.getdata();
			g.update_node( e2 );
			break;
		case 6:
			g.show_graph();
			break;
		default:
		{
			cerr&lt;&lt;"\t Invalid Chooice!.....Good Bye\n";
			flag=false;
		}
		
		}//end switch
	}*/
}//program end

//graph functions
void graph::unprocessed()
{
	for(int i=0;i&lt;count;i++)
		nodes[i].flag=false;
}

bool graph::processed(keytype k)
{
	int i=findnode(k);
	if(nodes[i].flag==true)
		return false;
	nodes[i].flag=true;
	return true;
	
}
bool graph::unprocessed1(keytype k)
{
	int i=findnode(k);
	if(nodes[i].flag==false)
		return true;
	return false;
}


</TEXTAREA> <!-- Search Google -->
<CENTER>
<FORM action=http://www.google.com/custom method=get target=_top>
<TABLE bgColor=#ffffff>
  <TBODY>
  <TR>
    <TD vAlign=top noWrap align=left height=32><A 
      href="http://www.google.com/"><IMG alt=Google 
      src="110_files/Logo_25wht.gif" align=middle border=0></IMG></A> <LABEL 
      style="DISPLAY: none" for=sbi>Enter your search terms</LABEL> <INPUT 
      id=sbi maxLength=255 size=40 name=q></INPUT> <LABEL style="DISPLAY: none" 
      for=sbb>Submit search form</LABEL> <INPUT id=sbb type=submit value=Search name=sa></INPUT> <INPUT type=hidden 
      value=pub-9653171024150495 name=client></INPUT> <INPUT type=hidden value=1 
      name=forid></INPUT> <INPUT type=hidden value=ISO-8859-1 name=ie></INPUT> 
      <INPUT type=hidden value=ISO-8859-1 name=oe></INPUT> <INPUT type=hidden 
      value=active name=safe></INPUT> <INPUT type=hidden 
      value=GALT:#008000;GL:1;DIV:#336699;VLC:663399;AH:center;BGC:FFFFFF;LBGC:336699;ALC:0000FF;LC:0000FF;T:000000;GFNT:0000FF;GIMP:0000FF;FORID:1 
      name=cof></INPUT> <INPUT type=hidden value=en name=hl></INPUT> 
  </TD></TR></TBODY></TABLE></FORM></CENTER><!-- Search Google -->
<H3><A 
href="http://www2.webng.com/amrlearn/Index.html">Home</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www2.webng.com/amrlearn/109.html">Previous</A>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www2.webng.com/amrlearn/115.html">Next</A></H3></DIV></BODY></HTML>
