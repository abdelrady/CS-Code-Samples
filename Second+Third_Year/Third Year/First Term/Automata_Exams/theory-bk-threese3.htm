<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html -->
<HTML><HEAD><TITLE></TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1256"><!--Created by TeX4ht from theory-bk-three.tex-->
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff>[<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese4.html">next</A>] 
[<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese2.html">prev</A>] 
[<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese2.html#tailtheory-bk-threese2.html">prev-tail</A>] 
[<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#tailtheory-bk-threese3.html">tail</A>] 
[<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-three.html#theory-bk-threese3.html">up</A>] 

<H3>3.3 <A name=40003-110003.3>&nbsp;</A><A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk.html#Q2-40003-11" 
name=Q1-40003-11>Context-Free Languages</A></H3>
<P>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q1-40003-12" 
name=Q2-40003-12>From Context-Free Grammars to Type 2 Grammars</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q1-40003-13" 
name=Q2-40003-13>From Context-Free Grammars to Pushdown Automata</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q1-40003-14" 
name=Q2-40003-14>From Context-Free Grammars to Recursive Finite-Domain 
Programs</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q1-40003-15" 
name=Q2-40003-15>From Recursive Finite-Domain Programs to 
Context-FreeGrammars</A> <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q1-40003-16" 
name=Q2-40003-16>The Nonterminal Symbols of G</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q1-40003-17" 
name=Q2-40003-17>The Production Rules of G</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q1-40003-18" 
name=Q2-40003-18>L(G) is Contained in L(P)</A> 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q1-40003-19" 
name=Q2-40003-19>L(P) is Contained in L(G)</A> <A name=40003-11001></A>
<P>Pushdown automata can be characterized by Type 2<A name=40003-11002> 
</A>grammars or, equivalently, by context-free grammars. 
<P>Specifically, a Type 0 grammar G = &lt;N, <IMG alt=S 
src="theory-bk-threese3_files/cmr10-6.gif">, P, S&gt; is said to be 
<I>context-free</I> if each of its production rules has exactly one nonterminal 
symbol on its left hand side, that is, if each of its production rules is of the 
form A <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
src="theory-bk-threese3_files/cmmi10-b.gif">. 
<P>The grammar is called context-free because it provides no mechanism to 
restrict the usage of a production rule A <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
src="theory-bk-threese3_files/cmmi10-b.gif"> within some specific context. 
However, in a Type 0 grammar such a restriction can be achieved by using a 
production rule of the form <IMG alt=b 
src="theory-bk-threese3_files/cmmi10-c.gif" align=middle>A<IMG alt=g 
src="theory-bk-threese3_files/cmmi10-d.gif"> <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=b 
src="theory-bk-threese3_files/cmmi10-c.gif" align=middle><IMG alt=a 
src="theory-bk-threese3_files/cmmi10-b.gif"><IMG alt=g 
src="theory-bk-threese3_files/cmmi10-d.gif"> to specify that A <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
src="theory-bk-threese3_files/cmmi10-b.gif"> is to be used only within the 
context of <IMG alt=b src="theory-bk-threese3_files/cmmi10-c.gif" align=middle> 
and <IMG alt=g src="theory-bk-threese3_files/cmmi10-d.gif">. 
<P>The languages that context-free grammars generate are called <I>context-free 
languages</I>. 
<P><STRONG>Example&nbsp;3.3.1</STRONG> <A 
name=40003-11003t3.3.1>&nbsp;</A>&nbsp; The language { 
a<SUP>i<SUB>1</SUB></SUP>b<SUP>i<SUB>1</SUB></SUP>a<SUP>i<SUB>2</SUB></SUP>b<SUP>i<SUB>2</SUB></SUP> 
<IMG alt=. src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> 
a<SUP>i<SUB>n</SUB></SUP>b<SUP>i<SUB>n</SUB></SUP> | n, i<SUB>1</SUB>,&nbsp;. . 
. ,&nbsp;i<SUB>n</SUB> <IMG alt=">=" 
src="theory-bk-threese3_files/cmsy10-15.gif" align=middle> 0 } is generated by 
the context-free grammar &lt;N, <IMG alt=S 
src="theory-bk-threese3_files/cmr10-6.gif">, P, S&gt;, whose production rules 
are given below. 
<P>
<CENTER><PRE><IMG alt="  S  -->   SS&#10;    -->   A&#10;    -->   e&#10;A   -->   aAb&#10;    -->   ab" src="theory-bk-threese3_files/theory-bk-three16x.gif"></PRE></CENTER>
<P><IMG alt=PICT src="theory-bk-threese3_files/theory-bk-three17x.gif"> 
<P>
<P><EM><A name=40003-12000>&nbsp;</A><A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q2-40003-12" 
name=Q1-40003-12>From Context-Free Grammars to Type 2 Grammars</A></EM> 
<P>Recall that a Type 2 grammar is a context-free grammar G = &lt;N, <IMG alt=S 
src="theory-bk-threese3_files/cmr10-6.gif">, P, S&gt; in which A <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=e 
src="theory-bk-threese3_files/cmmi10-f.gif"> in P implies that A = S and that no 
right-hand side of the production rules contains S. By the following theorem it 
follows that context-free grammars and Type 2 grammars act as "maximal" and 
"minimal" grammars for the same class of languages. 
<P><STRONG>Theorem&nbsp;3.3.1</STRONG> <A 
name=40003-12001t3.3.1>&nbsp;</A>&nbsp; Each context-free language is also a 
Type 2 language. 
<P>
<P><STRONG>Proof&nbsp;</STRONG> <A name=40003-12002t>&nbsp;</A>&nbsp; Consider 
any context-free grammar G<SUB>1</SUB> = &lt;N, <IMG alt=S 
src="theory-bk-threese3_files/cmr10-6.gif">, P<SUB>1</SUB>, S<SUB>1</SUB>&gt;. A 
Type 2 grammar G<SUB>2</SUB> = &lt;N <IMG alt=" U " 
src="theory-bk-threese3_files/cmsy10-5b.gif"> {S<SUB>2</SUB>}, <IMG alt=S 
src="theory-bk-threese3_files/cmr10-6.gif">, P<SUB>2</SUB>, S<SUB>2</SUB>&gt; 
satisfies L(G<SUB>2</SUB>) = L(G<SUB>1</SUB>), if S<SUB>2</SUB> is a new symbol 
and P<SUB>2</SUB> is obtained from P<SUB>1</SUB> in the following way. 
<P>Initialize P<SUB>2</SUB> to equal P<SUB>1</SUB> <IMG alt=" U " 
src="theory-bk-threese3_files/cmsy10-5b.gif"> {S<SUB>2</SUB> <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> S<SUB>1</SUB>}. Then, as long as 
P<SUB>2</SUB> contains a production rule of the form A <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=e 
src="theory-bk-threese3_files/cmmi10-f.gif"> for some A<IMG alt=/= 
src="theory-bk-threese3_files/theory-bk-three18x.gif" align=middle> 
S<SUB>2</SUB>, modify P<SUB>2</SUB> as follows. 
<OL type=a>
  <LI><A name=40003-12003xa>&nbsp;</A>Delete the production rule A <IMG 
  alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=e 
  src="theory-bk-threese3_files/cmmi10-f.gif"> from P<SUB>2</SUB>. 
  <LI><A name=40003-12004xb>&nbsp;</A>Add a production rule to P<SUB>2</SUB> of 
  the form B <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG 
  alt=a src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>A</SUB> as long as such 
  new production rules can be formed. <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>A</SUB> is assumed to be the 
  string <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif"> with one 
  appearance of A omitted in it, and <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"> is assumed to be the right-hand 
  side of a production rule of the form B <IMG alt="-->" 
  src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"> that is already in P<SUB>2</SUB>. 
  If <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>A</SUB> = <IMG 
  alt=e src="theory-bk-threese3_files/cmmi10-f.gif"> and the production rule B 
  <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=e 
  src="theory-bk-threese3_files/cmmi10-f.gif"> has been removed earlier from 
  P<SUB>2</SUB>, then the production rule is not reinserted to 
  P<SUB>2</SUB>.</LI></OL>No addition of a production rule of the form B <IMG 
alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>A</SUB> to P<SUB>2</SUB> 
changes the generated language, because any usage of the production rule can be 
simulated by the pair B <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
src="theory-bk-threese3_files/cmmi10-b.gif"> and A <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=e 
src="theory-bk-threese3_files/cmmi10-f.gif"> of production rules. 
<P>Similarly, no deletion of a production rule A <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=e 
src="theory-bk-threese3_files/cmmi10-f.gif"> from P<SUB>2</SUB> affects the 
generated language, because each subderivation C <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=b 
src="theory-bk-threese3_files/cmmi10-c.gif" align=middle><SUB>1</SUB>A<IMG alt=b 
src="theory-bk-threese3_files/cmmi10-c.gif" align=middle><SUB>2</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=g 
src="theory-bk-threese3_files/cmmi10-d.gif"><SUB>1</SUB>A<IMG alt=g 
src="theory-bk-threese3_files/cmmi10-d.gif"><SUB>2</SUB> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=g 
src="theory-bk-threese3_files/cmmi10-d.gif"><SUB>1</SUB><IMG alt=g 
src="theory-bk-threese3_files/cmmi10-d.gif"><SUB>2</SUB> which uses A <IMG 
alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=e 
src="theory-bk-threese3_files/cmmi10-f.gif"> can be replaced with an equivalent 
subderivation of the form C <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=b 
src="theory-bk-threese3_files/cmmi10-c.gif" align=middle><SUB>1</SUB><IMG alt=b 
src="theory-bk-threese3_files/cmmi10-c.gif" align=middle><SUB>2</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=g 
src="theory-bk-threese3_files/cmmi10-d.gif"><SUB>1</SUB><IMG alt=g 
src="theory-bk-threese3_files/cmmi10-d.gif"><SUB>2</SUB>. <IMG alt=" *** " 
src="theory-bk-threese3_files/theory-bk-three1x.gif"> 
<P>
<P><STRONG>Example&nbsp;3.3.2</STRONG> <A 
name=40003-12005t3.3.2>&nbsp;</A>&nbsp; Let G<SUB>1</SUB> be the context-free 
grammar whose production rules are listed below. 
<P>
<CENTER><PRE><IMG alt=" S   -->  e&#10; 1  -->  S aCC&#10;C   -->  e 1&#10;    -->  Dab&#10;D   -->  S&#10;         1" src="theory-bk-threese3_files/theory-bk-three19x.gif"></PRE></CENTER>
<P>The construction in the proof of Theorem&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-12001t3.3.1">3.3.1</A> 
implies the following equivalent grammars, where G<SUB>2</SUB> is a Type 2 
grammar. 
<P>
<CENTER><PRE><IMG alt="            '               '               '&#10;          G 1             G2              G3              G2&#10; Added-S2--->-S1-    RemovedS1-- >-e-    RemovedC--->-e-    RemovedD--->-e-&#10;S2  -->  S1       S2  -->  S1       S2 -->   S1       S2 -->   S1&#10;S1  -->  e            -->  e           -->   e           -->   e&#10;    -->  S1aCC    S1  -->  S1aCC    S1 -->   S1aCC    S1 -->   S1aCC&#10; C  -->  e            -->  aCC         -->   S1aC        -->   S1aC&#10;    -->  Dab       C  -->  e           -->   S1a         -->   S1a&#10; D  -->  S1           -->  Dab         -->   aCC         -->   aCC&#10;                 D  -->  S1          -->   aC          -->   aC&#10;                    -->  e           -->   a           -->   a&#10;                                 C -->   Dab       C -->   Dab&#10;                                 D -->   S1          -->   ab&#10;                                   -->   e        D  -->   S1" src="theory-bk-threese3_files/theory-bk-three20x.gif"></PRE></CENTER>
<P><IMG alt=PICT src="theory-bk-threese3_files/theory-bk-three21x.gif"> 
<P>
<P><EM><A name=40003-13000>&nbsp;</A><A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q2-40003-13" 
name=Q1-40003-13>From Context-Free Grammars to Pushdown Automata</A></EM> 
<P>Pushdown automata and recursive finite-domain programs process their inputs 
from left to right. To enable such entities to trace derivations of context-free 
grammars, the following lemma considers a similar property in the derivations of 
context-free grammars. 
<P><STRONG>Lemma&nbsp;3.3.1</STRONG> <A name=40003-13001t3.3.1>&nbsp;</A>&nbsp; 
If a nonterminal symbol A derives a string <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle> of terminal symbols 
in a context-free grammar G, then <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle> has a leftmost<A 
name=40003-13002> </A>derivation from A in G. 
<P>
<P><STRONG>Proof&nbsp;</STRONG> <A name=40003-13003t>&nbsp;</A>&nbsp; The proof 
is by contradiction. Recall that in context-free grammars the leftmost 
derivations <IMG alt=r src="theory-bk-threese3_files/cmmi10-1a.gif" 
align=middle><SUB>1</SUB> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>2</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>n</SUB> replace 
the leftmost nonterminal symbol in each sentential form <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>i</SUB>, i = 1, 
2, . . . , n - 1. 
<P>The proof relies on the observation that the ordering in which the 
nonterminal symbols are replaced in the sentential forms is of no importance for 
the derivations in context-free grammars. Each nonterminal symbol in each 
sentential form is expanded without any correlation to its context in the 
sentential form. 
<P>Consider any context-free grammar G. For the purpose of the proof assume that 
a string <IMG alt=r src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle> 
of terminal symbols has a derivation of length n from a nonterminal symbol A. In 
addition, assume that <IMG alt=r src="theory-bk-threese3_files/cmmi10-1a.gif" 
align=middle> has no leftmost derivation from A. 
<P>Let A <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>1</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>m</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>n</SUB> = <IMG 
alt=r src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle> be a derivation 
of length n in which A <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>1</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>m</SUB> is a 
leftmost subderivation. In addition, assume that m is maximized over the 
derivations A <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG 
alt=r src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle> of length n. By 
the assumption that <IMG alt=r src="theory-bk-threese3_files/cmmi10-1a.gif" 
align=middle> has no leftmost derivation from A, it follows that m &lt; n - 1. 
<P>The derivation in question satisfies <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>m</SUB> = wB<IMG 
alt=^r src="theory-bk-threese3_files/theory-bk-three22x.gif"><SUB>m</SUB>, <IMG 
alt=r src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>m+1</SUB> = 
wB<IMG alt=^r 
src="theory-bk-threese3_files/theory-bk-three23x.gif"><SUB>m+1</SUB>,&nbsp;. . . 
,&nbsp;<IMG alt=r src="theory-bk-threese3_files/cmmi10-1a.gif" 
align=middle><SUB>k</SUB> = wB<IMG alt=^r 
src="theory-bk-threese3_files/theory-bk-three24x.gif"><SUB>k</SUB>, <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>k+1</SUB> = w<IMG 
alt=b src="theory-bk-threese3_files/cmmi10-c.gif" align=middle><IMG alt=^r 
src="theory-bk-threese3_files/theory-bk-three25x.gif"><SUB>k</SUB> for some 
string w of terminal symbols, production rule B <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=b 
src="theory-bk-threese3_files/cmmi10-c.gif" align=middle>, m &lt; k &lt; n, and 
<IMG alt=^r 
src="theory-bk-threese3_files/theory-bk-three26x.gif"><SUB>m</SUB>,&nbsp;. . . 
,&nbsp;<IMG alt=^r 
src="theory-bk-threese3_files/theory-bk-three27x.gif"><SUB>k</SUB>. Thus A <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>1</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>m-1</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>m</SUB> = wB<IMG 
alt=^r src="theory-bk-threese3_files/theory-bk-three28x.gif"><SUB>m</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> w<IMG alt=b 
src="theory-bk-threese3_files/cmmi10-c.gif" align=middle><IMG alt=^r 
src="theory-bk-threese3_files/theory-bk-three29x.gif"><SUB>m</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> w<IMG alt=b 
src="theory-bk-threese3_files/cmmi10-c.gif" align=middle><IMG alt=^r 
src="theory-bk-threese3_files/theory-bk-three30x.gif"><SUB>m+1</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> w<IMG alt=b 
src="theory-bk-threese3_files/cmmi10-c.gif" align=middle><IMG alt=^r 
src="theory-bk-threese3_files/theory-bk-three31x.gif"><SUB>k</SUB> = <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>k+1</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>n</SUB> = <IMG 
alt=r src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle> is also a 
derivation of <IMG alt=r src="theory-bk-threese3_files/cmmi10-1a.gif" 
align=middle> from A of length n. 
<P>However, in this new derivation A <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>1</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle><SUB>m</SUB> <IMG 
alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> w<IMG alt=b 
src="theory-bk-threese3_files/cmmi10-c.gif" align=middle><IMG alt=r^ 
src="theory-bk-threese3_files/theory-bk-three32x.gif"><SUB>m</SUB> is a leftmost 
subderivation of length m + 1. Consequently, contradicting the existence of a 
maximal m as implied above, from the assumption that <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle> has only nonleftmost 
derivations from A. 
<P>As a result, the assumption that <IMG alt=r 
src="theory-bk-threese3_files/cmmi10-1a.gif" align=middle> has no leftmost 
derivation from A is also contradicted. <IMG alt=" *** " 
src="theory-bk-threese3_files/theory-bk-three1x.gif"> 
<P>
<P>The proof of the following theorem shows how pushdown automata can trace the 
derivations of context-free grammars. 
<P><STRONG>Theorem&nbsp;3.3.2</STRONG> <A 
name=40003-13004t3.3.2>&nbsp;</A>&nbsp; Each context-free language is accepted 
by a pushdown automaton. 
<P>
<P><STRONG>Proof&nbsp;</STRONG> <A name=40003-13005t>&nbsp;</A>&nbsp; Consider 
any context-free grammar G = &lt;N, <IMG alt=S 
src="theory-bk-threese3_files/cmr10-6.gif">, P, S&gt;. With no loss of 
generality assume that Z<SUB>0</SUB> is not in N <IMG alt=" U " 
src="theory-bk-threese3_files/cmsy10-5b.gif"> <IMG alt=S 
src="theory-bk-threese3_files/cmr10-6.gif">. L(G) is accepted by the pushdown 
automaton M = &lt;Q, <IMG alt=S src="theory-bk-threese3_files/cmr10-6.gif">, N 
<IMG alt=" U " src="theory-bk-threese3_files/cmsy10-5b.gif"> <IMG alt=S 
src="theory-bk-threese3_files/cmr10-6.gif"> <IMG alt=" U " 
src="theory-bk-threese3_files/cmsy10-5b.gif"> {Z<SUB>0</SUB>}, <IMG alt=d 
src="theory-bk-threese3_files/cmmi10-e.gif">, q<SUB>0</SUB>, Z<SUB>0</SUB>, 
{q<SUB>f</SUB>}&gt; whose transition table <IMG alt=d 
src="theory-bk-threese3_files/cmmi10-e.gif"> consists of the following 
derivation rules. 
<OL type=a>
  <LI><A name=40003-13006xa>&nbsp;</A>A transition rule of the form 
  (q<SUB>0</SUB>, <IMG alt=e src="theory-bk-threese3_files/cmmi10-f.gif">, <IMG 
  alt=e src="theory-bk-threese3_files/cmmi10-f.gif">, q<SUB>1</SUB>, S). 
  <LI><A name=40003-13007xb>&nbsp;</A>A sequence of transition rules for each A 
  <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"> in P. Each such sequence starts 
  and ends at state q<SUB>1</SUB>, and replaces a nonterminal symbol A on top of 
  the pushdown store with the string <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"> in reverse order. 
  <LI><A name=40003-13008xc>&nbsp;</A>A transition rule of the form 
  (q<SUB>1</SUB>, a, a, q<SUB>1</SUB>, <IMG alt=e 
  src="theory-bk-threese3_files/cmmi10-f.gif">), for each terminal symbol a in 
  the alphabet <IMG alt=S src="theory-bk-threese3_files/cmr10-6.gif">. 
  <LI><A name=40003-13009xd>&nbsp;</A>A transition rule of the form 
  (q<SUB>1</SUB>, <IMG alt=e src="theory-bk-threese3_files/cmmi10-f.gif">, 
  Z<SUB>0</SUB>, q<SUB>f</SUB>, Z<SUB>0</SUB>).</LI></OL>Intuitively, we know that 
on a given input x the pushdown automaton M nondeterministically traces a 
leftmost derivation in G that starts at S and ends at&nbsp;x. At each stage of 
the tracing, the portion of the input that has already been read together with 
the content of the pushdown store in reverse order, record the sentential form 
in the corresponding stage of the derivation. 
<P>The transition rule in (a) is used for pushing the first sentential form S 
into the pushdown store. The transition rules in (b) are used for replacing the 
leftmost nonterminal symbol in a given sentential form with the right-hand side 
of an appropriate production rule. The transition rules in (c) are used for 
matching the leading terminal symbols in the sentential forms with the 
corresponding symbols in the given input x. The purpose of the production rule 
in (d) is to move the pushdown automaton into an accepting state upon reaching 
the end of a derivation. 
<P>By induction on n it can be verified that x has a leftmost derivation in G if 
and only if M has an accepting computation on x, where the derivation and the 
computation have the following forms with u<SUB>i</SUB>v<SUB>i</SUB> = x for 1 
<IMG alt="<=" src="theory-bk-threese3_files/cmsy10-14.gif" align=middle> i &lt; 
n. 
<P>
<CENTER><PRE><IMG alt=" S                         (q0x,Z0) |-  (q1x,Z0S)&#10;==>  u1A1r1                  |- * (u1q1v1,Z0rrevA1)&#10;==>  u2A2r2                  |- * (u2q1v2,Z0r1revA2)&#10;==>  ...                      |- * ...       2&#10;==>  un-1An-1rn-1            |- * (un- 1q1vn-1,Z0rrevAn- 1)&#10;==>  x                       |- * (xq1,Z0)  |- (xqf,Zn0-)1" src="theory-bk-threese3_files/theory-bk-three33x.gif"></PRE></CENTER>
<P><IMG alt=PICT src="theory-bk-threese3_files/theory-bk-three34x.gif"> 
<P>
<P><STRONG>Example&nbsp;3.3.3</STRONG> <A 
name=40003-13010t3.3.3>&nbsp;</A>&nbsp; If G is the context-free grammar of 
Example&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-11003t3.3.1">3.3.1</A>, 
then the language L(G) is accepted by the pushdown automaton M, whose transition 
diagram is given in Figure&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-13011r3.3.1">3.3.1</A>(a). 

<HR>

<CENTER>
<TABLE>
  <TBODY>
  <TR>
    <TD><A name=40003-13011r3.3.1>&nbsp;</A> <IMG alt=[PICT] 
      src="theory-bk-threese3_files/theory-bk-three-3-3-1-a.jpg"> (a) <IMG 
      alt=[PICT] src="theory-bk-threese3_files/theory-bk-three-3-3-1-b.jpg"> (b) 
      <A name=40003-13011r3.3.1>&nbsp;</A> <BR>
      <TABLE>
        <TBODY>
        <TR vAlign=baseline>
          <TD><NOBR><STRONG>Figure 3.3.1</STRONG></NOBR></TD>
          <TD>(a) A pushdown automaton that accepts the language generated by 
            the grammar of Example&nbsp;<A 
            href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-13010t3.3.3">3.3.3</A>. 
            (b) A leftmost derivation in the grammar and the corresponding 
            computation by the pushdown automaton. </TD></TR></TBODY></TABLE>
      <CENTER></CENTER></TD></TR></TBODY></TABLE></CENTER>
<HR>

<P>aabbab has the leftmost derivation S <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> SS <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> AS <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> aAbS <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> aabbS <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> aabbA <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> aabbab in G. Figure&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-13011r3.3.1">3.3.1</A>(b) 
shows the corresponding configurations of M in its computation on such an input. 
<IMG alt=" *** " src="theory-bk-threese3_files/theory-bk-three1x.gif"> 
<P>
<P><EM><A name=40003-14000>&nbsp;</A><A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q2-40003-14" 
name=Q1-40003-14>From Context-Free Grammars to Recursive Finite-Domain 
<BR>Programs</A></EM> 
<P>By Theorems&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese2.html#40002-9005t3.2.1">3.2.1</A> 
and&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-13004t3.3.2">3.3.2</A> 
each context-free language is accepted by a recursive finite-domain program. For 
a given context-free grammar G = &lt;N, <IMG alt=S 
src="theory-bk-threese3_files/cmr10-6.gif">, P, S&gt;, the recursive 
finite-domain program T that accepts L(G) can be of the following form. 
<P>T on a given input x nondeterministically traces a leftmost derivation that 
starts at S. If the leftmost derivation provides the string x, then T accepts 
its input. Otherwise, T rejects the input. 
<P>T has one procedure for each nonterminal symbol in N, and one procedure for 
each terminal symbol in <IMG alt=S src="theory-bk-threese3_files/cmr10-6.gif">. 
A procedure that corresponds to a nonterminal symbol A is responsible for 
initiating a tracing of a leftmost subderivation that starts at A. The procedure 
does so by nondeterministically choosing a production rule of the form A <IMG 
alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> X<SUB>1</SUB> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. 
src="theory-bk-threese3_files/cmsy10-1.gif"> X<SUB>m</SUB>, and then calling the 
procedures that correspond to X<SUB>1</SUB>,&nbsp;. . . ,&nbsp;X<SUB>m</SUB> in 
the given order. On the other hand, each procedure that corresponds to a 
terminal symbol is responsible for reading an input symbol and verifying that 
the symbol is equal to its corresponding terminal symbol. 
<P>Each of the procedures above returns the control to the point of invocation, 
upon successfully completing the given responsibilities. However, each of the 
procedures terminates the computation at a nonaccepting configuration upon 
determining that the given responsibility cannot be carried out. 
<P>The main program starts a computation by invoking the procedure that 
corresponds to the start symbol S. Upon the return of control the main program 
terminates the computation, where the termination is in an accepting 
configuration if and only if the remainder of the input is empty. 
<P>The recursive finite-domain program T can be as depicted in Figure&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-14001r3.3.2">3.3.2</A>. 

<HR>

<CENTER>
<TABLE>
  <TBODY>
  <TR>
    <TD><A name=40003-14001r3.3.2>&nbsp;</A> 
      <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
        <TBODY>
        <TR>
          <TD><PRE><B>call</B> S()
<B>if</B> <I>eof</I> <B>then accept</B>
<B>reject</B>
<B>procedure</B> A()         /* For each nonterminal symbol A.&nbsp;*/
    <B>do</B>
        <IMG alt=".&#10;.." src="theory-bk-threese3_files/theory-bk-three35x.gif">
    <B>or</B>                   /* For each production rule of the form
                           A <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> X<SUB>1</SUB> <IMG alt=. src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. src="theory-bk-threese3_files/cmsy10-1.gif"> X<SUB>m</SUB>.&nbsp;&nbsp;&nbsp;                         */
        <B>call</B> X<SUB>1</SUB>() <IMG alt=. src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. src="theory-bk-threese3_files/cmsy10-1.gif"> <IMG alt=. src="theory-bk-threese3_files/cmsy10-1.gif"> <B>call</B> X<SUB>m</SUB>()
      <B>return</B>
    <B>or</B>
        <IMG alt=".&#10;.." src="theory-bk-threese3_files/theory-bk-three36x.gif">
    <B>until</B> true
<B>end</B>
<B>procedure</B> a()                /* For each terminal symbol a.&nbsp;*/
    <B>read</B> <TT>symbol</TT>
    <B>if</B> <TT>symbol</TT> = a <B>then return</B>
    <B>reject</B>
<B>end</B>                                                                                     </PRE></TD></TR></TBODY></TABLE><A 
      name=40003-14001r3.3.2>&nbsp;</A> <BR>
      <TABLE>
        <TBODY>
        <TR vAlign=baseline>
          <TD><NOBR><STRONG>Figure 3.3.2</STRONG></NOBR></TD>
          <TD>A scheme of recursive finite-domain programs that simulate 
            context-free grammars.</TD></TR></TBODY></TABLE>
      <CENTER></CENTER></TD></TR></TBODY></TABLE></CENTER>
<HR>

<P><STRONG>Example&nbsp;3.3.4</STRONG> <A 
name=40003-14002t3.3.4>&nbsp;</A>&nbsp; If G is the context-free grammar of 
Example&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-11003t3.3.1">3.3.1</A>, 
then L(G) is accepted by the recursive finite-domain program in Figure&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-14003r3.3.3">3.3.3</A>. 

<HR>

<CENTER>
<TABLE>
  <TBODY>
  <TR>
    <TD><A name=40003-14003r3.3.3>&nbsp;</A> 
      <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
        <TBODY>
        <TR>
          <TD><PRE><B>call</B> S()
<B>if</B> <I>eof</I> <B>then accept</B>
<B>reject</B>
<B>procedure</B> S()
    <B>do</B>                                                           /* S <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> SS  &nbsp;*/
        <B>call</B> S() <B>call</B> S() <B>return</B>
    <B>or</B>                                                           /* S <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> A   &nbsp;*/
        <B>call</B> A() <B>return</B>
    <B>or</B>                                                           /* S <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=e src="theory-bk-threese3_files/cmmi10-f.gif">    &nbsp;*/
        <B>return</B>
    <B>until</B> true
<B>end</B>
<B>procedure</B> A()
    <B>do</B>                                                           /* A <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> aAb&nbsp;*/
        <B>call</B> a() <B>call</B> A() <B>call</B> b() <B>return</B>
    <B>or</B>                                                           /* A <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> ab  &nbsp;*/
        <B>call</B> a() <B>call</B> b() <B>return</B>
    <B>until</B> true
<B>end</B>
<B>procedure</B> a()
    <B>read</B> <TT>symbol</TT>
    <B>if</B> <TT>symbol</TT> = a <B>then return</B>
    <B>reject</B>
<B>end</B>
<B>procedure</B> b()
    <B>read</B> <TT>symbol</TT>
    <B>if</B> <TT>symbol</TT> = b <B>then return</B>
    <B>reject</B>
<B>end</B>                                                                                     </PRE></TD></TR></TBODY></TABLE><A 
      name=40003-14003r3.3.3>&nbsp;</A> <BR>
      <TABLE>
        <TBODY>
        <TR vAlign=baseline>
          <TD><NOBR><STRONG>Figure 3.3.3</STRONG></NOBR></TD>
          <TD>A recursive finite-domain program for the grammar of 
            Example&nbsp;<A 
            href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-11003t3.3.1">3.3.1</A>. 
          </TD></TR></TBODY></TABLE>
      <CENTER></CENTER></TD></TR></TBODY></TABLE></CENTER>
<HR>

<P>On input aabbab the recursive finite-domain program traces the derivation S 
<IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> SS <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> AS <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> aAbS <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> aabbS <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> aabbA <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> aabbab by calling its procedures 
in the order indicated in Figure&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-14004r3.3.4">3.3.4</A>. 
<IMG alt=" *** " src="theory-bk-threese3_files/theory-bk-three1x.gif"> 
<P>
<HR>

<CENTER>
<TABLE>
  <TBODY>
  <TR>
    <TD><A name=40003-14004r3.3.4>&nbsp;</A> <A 
      name=40003-14004r3.3.4>&nbsp;</A> <BR><IMG alt=[PICT] 
      src="theory-bk-threese3_files/theory-bk-three-3-3-4.jpg"> <BR>
      <TABLE>
        <TBODY>
        <TR vAlign=baseline>
          <TD><NOBR><STRONG>Figure 3.3.4</STRONG></NOBR></TD>
          <TD>The calls to procedures that the program of Figure&nbsp;<A 
            href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-14003r3.3.3">3.3.3</A> 
            makes on input aabbab. </TD></TR></TBODY></TABLE>
      <CENTER></CENTER></TD></TR></TBODY></TABLE></CENTER>
<HR>

<P><EM><A name=40003-15000>&nbsp;</A><A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q2-40003-15" 
name=Q1-40003-15>From Recursive Finite-Domain Programs to Context-Free 
<BR>Grammars</A></EM> 
<P>A close look at the proof of Theorem&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-twose3.html#30003-14002t2.3.2">2.3.2</A> 
indicates how a given finite-memory program P can be simulated by a Type 3 
grammar G = &lt;N, <IMG alt=S src="theory-bk-threese3_files/cmr10-6.gif">, P, 
S&gt;. 
<P>The grammar uses its nonterminal symbols to record the states of P. Each 
production rule of the form A <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> aB in the grammar is used to 
simulate a subcomputation of P that starts at the state recorded by A, ends at 
the state recorded by B, and reads an input symbol a. However, each production 
rule of the form A <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> 
a in the grammar is used to simulate a subcomputation of P that starts at the 
state that is recorded by A, ends at an accepting state, and reads an input 
symbol&nbsp;a. The start symbol S of G is used to record the initial state of P. 
The production rule S <IMG alt="-->" 
src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=e 
src="theory-bk-threese3_files/cmmi10-f.gif"> is used to simulate an accepting 
computation of P in which no input value is read. 
<P>The proof of the following theorem relies on a similar approach. 
<P><STRONG>Theorem&nbsp;3.3.3</STRONG> <A 
name=40003-15001t3.3.3>&nbsp;</A>&nbsp; Every language that is accepted by a 
recursive finite-domain program is a context-free language. 
<P>
<P><STRONG>Proof&nbsp;</STRONG> <A name=40003-15002t>&nbsp;</A>&nbsp; Consider 
any recursive finite-domain program P. With no loss of generality it can be 
assumed that the program has no write instructions. The language that is 
accepted by P can be generated by a context-free grammar G that simulates the 
computations of P. The nonterminal symbols of G are used to indicate the start 
and end states of subcomputations of P that have to be simulated, and the 
production rules of G are used for simulating transitions between states of P. 
<P><EM><A name=40003-16000>&nbsp;</A><A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q2-40003-16" 
name=Q1-40003-16>The Nonterminal Symbols of G</A></EM> 
<P>Specifically, the nonterminal symbols of G consist of 
<OL type=a>
  <LI><A name=40003-16001xa>&nbsp;</A>A nonterminal symbol A<SUB>q</SUB>, for 
  each state q of P. Each such nonterminal symbol A<SUB>q</SUB> is used for 
  indicating that a subcomputation of P, which starts at state q and ends at an 
  accepting state, has to be simulated. Moreover, each execution of a return 
  instruction in the subcomputation must be for a call that is made previously 
  during the subcomputation. 
  <P>The start symbol of G is the nonterminal symbol A<SUB>q<SUB>0</SUB></SUB> 
  that corresponds to the initial state q<SUB>0</SUB> of P. </P>
  <LI><A name=40003-16002xb>&nbsp;</A>A nonterminal symbol A<SUB>q,p</SUB>, for 
  each pair of states q and p corresponding to instruction segments that are in 
  the same procedure of P. Each such nonterminal symbol A<SUB>q,p</SUB> is 
  introduced for indicating that a subcomputation, which starts at state q and 
  ends at state p, has to be simulated. In the subcomputation the number of 
  executions of return instructions has to equal the number of executions of 
  call instructions. Moreover, each execution of a return instruction in the 
  subcomputation must be for a call that is made previously during the 
  subcomputation. </LI></OL>
<P>
<P><EM><A name=40003-17000>&nbsp;</A><A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q2-40003-17" 
name=Q1-40003-17>The Production Rules of G</A></EM> 
<P>The production rules of G consist of 
<OL type=a>
  <LI><A name=40003-17001xa>&nbsp;</A>A production rule of the form 
  A<SUB>q</SUB> <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> 
  <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif">A<SUB>r</SUB>, and a 
  production rule of the form A<SUB>q,p</SUB> <IMG alt="-->" 
  src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif">A<SUB>r,p</SUB>, for each q, r, p, 
  and <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif"> that satisfy the 
  following condition. The instruction segment that corresponds to state q is 
  neither a call instruction nor a return instruction, and its execution can 
  take the program from state q to state r while reading <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif">. 
  <P>A production rule of the form A<SUB>q</SUB> <IMG alt="-->" 
  src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif">A<SUB>r</SUB> replaces the 
  objective of reaching an accepting state from state q with the objective of 
  reaching an accepting state from state r. 
  <P>A production rule of the form A<SUB>q,p</SUB> <IMG alt="-->" 
  src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif">A<SUB>r,p</SUB> replaces the 
  objective of reaching state p from state q with the objective of reaching 
  state p from state r. </P>
  <LI><A name=40003-17002xb>&nbsp;</A>A production rule of the form 
  A<SUB>q</SUB> <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> 
  <IMG alt=e src="theory-bk-threese3_files/cmmi10-f.gif">, for each state q that 
  corresponds to an <B>if</B> <I>eof</I> <B>then accept</B> instruction. 
  <LI><A name=40003-17003xc>&nbsp;</A>A production rule of the form 
  A<SUB>q</SUB> <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> 
  A<SUB>r</SUB>, for each state q that corresponds to a call instruction, where 
  r is the state reached from q. Each such production rule simulates an 
  execution of a <B>call</B> which is not matched by an execution of a 
  <B>return</B>. 
  <LI><A name=40003-17004xd>&nbsp;</A>A production rule of the form 
  A<SUB>q</SUB> <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> 
  A<SUB>r,s</SUB>A<SUB>t</SUB>, and a production rule of the form 
  A<SUB>q,p</SUB> <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> 
  A<SUB>r,s</SUB>A<SUB>t,p</SUB>, for each q, r, s, t, and p such that the 
  following conditions hold. 
  <OL type=1>
    <LI><A name=40003-17005xd1>&nbsp;</A>State q corresponds to a call 
    instruction whose execution at such a state causes the program to enter 
    state r. 
    <LI><A name=40003-17006xd2>&nbsp;</A>State s corresponds to a return 
    instruction in the called procedure, and the execution of the return 
    instruction at such a state takes the program to state t that is compatible 
    with r.</LI></OL>That is, the subcomputation that starts at state q is 
  decomposed into two subcomputations. One is to be performed by an invoked 
  procedure, starting at state r and ending at state s; the other takes on from 
  the instant that the control returns from the invoked procedure, starting at 
  state t. 
  <LI><A name=40003-17007xe>&nbsp;</A>A production rule of the form 
  A<SUB>q,q</SUB> <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> 
  <IMG alt=e src="theory-bk-threese3_files/cmmi10-f.gif"> for each state q that 
  corresponds to a <B>return</B> instruction. 
  <P>Each of the production rules above is used for terminating a successful 
  simulation of a subcomputation performed by an invoked procedure.</P></LI></OL>
<P><EM><A name=40003-18000>&nbsp;</A><A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q2-40003-18" 
name=Q1-40003-18>L(G) is Contained in L(P)</A></EM> 
<P>A proof by induction can be used to show that the construction above implies 
L(G) = L(P). 
<P>To show that L(G), is contained in L(P) it is sufficient to show that the 
following two conditions hold for each string <IMG alt=a 
src="theory-bk-threese3_files/cmmi10-b.gif"> of terminal symbols. 
<OL type=a>
  <LI><A name=40003-18001xa>&nbsp;</A>If A<SUB>q</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"> in G then P can reach from state 
  q an accepting state while reading <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif">, and in any prefix of the 
  subexecution sequence there must be at least as many executions of call 
  instructions as executions of return instructions. 
  <LI><A name=40003-18002xb>&nbsp;</A>If A<SUB>q,p</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"> in G, then P can reach state p 
  from state q while reading <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif">. In the subexecution sequence the 
  number of executions of return instructions must equal the number of 
  executions of call instructions, and in any prefix of the subexecution 
  sequence there must be at least as many executions of call instructions as 
  executions of return instructions. </LI></OL>
<P>The proof can be by induction on the number of steps i in the derivations. 
For i = 1, the only feasible derivations are those that have either the form 
A<SUB>q</SUB> <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG 
alt=e src="theory-bk-threese3_files/cmmi10-f.gif"> or the form A<SUB>p,p</SUB> 
<IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=e 
src="theory-bk-threese3_files/cmmi10-f.gif">. In the first case q corresponds to 
an accept instruction, and in the second case p corresponds to a return 
instruction. In both cases the subexecution sequences of the program are empty. 
<P>For i &gt; 1 the derivations must have either of the following forms. 
<OL type=a>
  <LI><A name=40003-18003xa>&nbsp;</A>A<SUB>q</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB>A<SUB>r</SUB> <IMG 
  alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB><IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> = <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif">, or A<SUB>q,p</SUB> <IMG 
  alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB>A<SUB>r,p</SUB> <IMG 
  alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB><IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> = <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif">. In either case, by definition 
  A<SUB>q</SUB> <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> 
  <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB>A<SUB>r</SUB> and 
  A<SUB>q,p</SUB> <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> 
  <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB>A<SUB>r,p</SUB> 
  correspond to subexecution sequences that start at state q, end at state r, 
  consume the input <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB>, and execute neither 
  a call instruction nor a return instruction. However, by the induction 
  hypothesis A<SUB>r</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> and A<SUB>r,p</SUB> 
  <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> correspond to 
  subexecution sequences that have the desired properties. Consequently, 
  A<SUB>q</SUB> <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* 
  <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif"> and A<SUB>q,p</SUB> 
  <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"> also correspond to subexecution 
  sequences that have the desired properties. 
  <LI><A name=40003-18004xb>&nbsp;</A>A<SUB>q</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif"> A<SUB>r,s</SUB>A<SUB>t</SUB> 
  <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB><IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB>, or A<SUB>q,p</SUB> 
  <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif"> 
  A<SUB>r,s</SUB>A<SUB>t,p</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB><IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB>, where 
  A<SUB>r,s</SUB> <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* 
  <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB>. In either 
  case, by definition q corresponds to a call instruction, r is the state that P 
  reaches from state q, s corresponds to a return instruction, and t is the 
  state that P reaches from state s. However, by the induction hypothesis 
  A<SUB>r,s</SUB> <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* 
  <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB>, 
  A<SUB>t</SUB> <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* 
  <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB>, and 
  A<SUB>t,p</SUB> <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* 
  <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> correspond 
  to subexecution sequences that have the desired properties. Consequently, 
  A<SUB>q</SUB> <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* 
  <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB><IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> and A<SUB>q,p</SUB> 
  <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB><IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> also correspond to 
  subexecution sequences that have the desired properties.</LI></OL>
<P><EM><A name=40003-19000>&nbsp;</A><A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#Q2-40003-19" 
name=Q1-40003-19>L(P) is Contained in L(G)</A></EM> 
<P>To show that L(P) is contained in L(G) it is sufficient to show that either 
of the following conditions holds for each subexecution sequence that reads <IMG 
alt=a src="theory-bk-threese3_files/cmmi10-b.gif">, starts at state q, ends at 
state p, and has at least as many executions of return instructions as of call 
instructions in each of the prefixes. 
<OL type=a>
  <LI><A name=40003-19001xa>&nbsp;</A>If p corresponds to an accepting state, 
  then G has a derivation of the form A<SUB>q</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif">. 
  <LI><A name=40003-19002xb>&nbsp;</A>If p corresponds to a return instruction 
  and the subexecution sequence has as many executions of call instructions as 
  of return instructions, then G has a derivation of the form A<SUB>q,p</SUB> 
  <IMG alt="==>" src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif">.</LI></OL>The proof is by induction 
on the number of moves i in the subexecution sequences. For i = 0 the 
subexecution sequences consume no input, and for them G has the corresponding 
derivations A<SUB>p</SUB> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=e 
src="theory-bk-threese3_files/cmmi10-f.gif"> and A<SUB>p,p</SUB> <IMG alt="==>" 
src="theory-bk-threese3_files/cmsy10-29.gif"> <IMG alt=e 
src="theory-bk-threese3_files/cmmi10-f.gif">, respectively. 
<P>For i &gt; 0 either of the following cases must hold. 
<OL type=a>
  <LI><A name=40003-19003xa>&nbsp;</A>q does not correspond to a call 
  instruction, or q corresponds to a call instruction that is not matched in the 
  subexecution sequence by a return instruction. In such a case, by executing a 
  single instruction segment the subexecution sequences in question enter some 
  state r from state q while consuming some input <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB>. 
  <P>Consequently, by definition, the grammar G has a production rule of the 
  form A<SUB>q</SUB> <IMG alt="-->" 
  src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB>A<SUB>r</SUB> if p is 
  an accepting state, and a production rule of the form A<SUB>q,p</SUB> <IMG 
  alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB>A<SUB>r,p</SUB> if p 
  corresponds to a return instruction. 
  <P>However, by the induction hypothesis the i-1 moves that start in state r 
  have in G a corresponding derivation of the form A<SUB>r</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> if p is an accepting 
  state, and of the form A<SUB>r,p</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> if p corresponds to a 
  return instruction. <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> is assumed to satisfy 
  <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB><IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> = <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif">. </P>
  <LI><A name=40003-19004xb>&nbsp;</A>q corresponds to a call instruction that 
  is matched in the subexecution sequence by a return instruction. In such a 
  case the subexecution sequence from state q enters some state r by executing 
  the call instruction that corresponds to state q. Moreover, the subexecution 
  sequence has a corresponding execution of a return instruction that takes the 
  subexecution sequence from some state s to some state t. 
  <P>Consequently, by definition, the grammar G has a production rule of the 
  form A<SUB>q</SUB> <IMG alt="-->" 
  src="theory-bk-threese3_files/cmsy10-21.gif"> A<SUB>r,s</SUB>A<SUB>t</SUB> if 
  p is an accepting state, and a production rule of the form A<SUB>q,p</SUB> 
  <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> 
  A<SUB>r,s</SUB>A<SUB>t,p</SUB> if p corresponds to a return instruction. 
  <P>However, by the induction hypothesis, the grammar G has a derivation of the 
  form A<SUB>r,s</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB> for the input <IMG 
  alt=a src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>1</SUB> that the 
  subexecution sequence consumes between states r and s. In addition, G has 
  either a derivation of the form A<SUB>t</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> or a derivation of 
  the form A<SUB>t,p</SUB> <IMG alt="==>" 
  src="theory-bk-threese3_files/cmsy10-29.gif">* <IMG alt=a 
  src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB>, respectively, for 
  the input <IMG alt=a src="theory-bk-threese3_files/cmmi10-b.gif"><SUB>2</SUB> 
  that the subexecution sequence consumes between states t and&nbsp;p, depending 
  on whether p is an accepting state or not. <IMG alt=" *** " 
  src="theory-bk-threese3_files/theory-bk-three1x.gif"></P></LI></OL>
<P>
<P><STRONG>Example&nbsp;3.3.5</STRONG> <A 
name=40003-19005t3.3.5>&nbsp;</A>&nbsp; Let P be the recursive finite-domain 
program in Figure&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-19006r3.3.5">3.3.5</A>(a), 
with {a, b} as a domain of the variables and a as initial value. 
<HR>

<CENTER>
<TABLE>
  <TBODY>
  <TR>
    <TD><A name=40003-19006r3.3.5>&nbsp;</A> 
      <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
        <TBODY>
        <TR>
          <TD><PRE><B>call</B> f(<TT>x</TT>)                               /* I<SUB>1</SUB>&nbsp;*/
<B>if</B> <I>eof</I> <B>then accept</B>                /* I<SUB>2</SUB>&nbsp;*/
<B>reject</B>                                    /* I<SUB>3</SUB>&nbsp;*/
<B>procedure</B> f(<TT>x</TT>)
    <B>do</B>                                     /* I<SUB>4</SUB>&nbsp;*/
        <B>return</B>                           /* I<SUB>5</SUB>&nbsp;*/
    <B>or</B>
        <B>read</B> <TT>x</TT>                           /* I<SUB>6</SUB>&nbsp;*/
        <B>call</B> f(<TT>x</TT>)                       /* I<SUB>7</SUB>&nbsp;*/
    <B>until</B> <TT>x</TT> = a                  /* I<SUB>8</SUB>&nbsp;*/
<B>end</B>                                                   </PRE></TD></TR></TBODY></TABLE>(a) 

      <DIV align=center><IMG 
      alt="A[1,a]     -->   A[4,a]                A[4,b],[5,a]  -->   A[5,b],[5,a]&#10;          -->   A[4,a],[5,a]A[2,a]                   -->   A[6,b],[5,a]&#10;          -->   A[4,a],[5,b]A[2,b]         A[4,b],[5,b]  -->   A[5,b],[5,b]&#10;A[2,a]     -->   e                              -->   A[6,b],[5,b]&#10;          -->   A[3,a]                A[5,a],[5,a]  -->   e&#10;A[2,b]     -->   e                    A[5,b],[5,b]  -->   e&#10;          -->   A[3,b]                 A[6,a],[5,a]  -->   aA[7,a],[5,a]&#10;A[4,a]     -->   A[5,a]                          -->   bA[7,b],[5,a]&#10;          -->   A[6,a]                A[6,a],[5,b]  -->   aA[7,a],[5,b]&#10;A[4,b]     -->   A[5,b]                           -->   bA[7,b],[5,b]&#10;          -->   A[6,b]                 A[6,b],[5,a]  -->   aA[7,a],[5,a]&#10;A[6,a]     -->   aA[7,a]                         -->   bA[7,b],[5,a]&#10;          -->   bA[7,b]                A[6,b],[5,b]  -->   aA[7,a],[5,b]&#10;A[6,b]     -->   aA[7,a]                         -->   bA[7,b],[5,b]&#10;          -->   bA[7,b]                A[7,a],[5,a]  -->   A[4,a],[5,a]A[8,a],[5,a]&#10;A[7,a]     -->   A[4,a],[5,a]A[8,a]                   -->   A[4,a],[5,b]A[8,b],[5,a]&#10;          -->   A[4,a],[5,b]A[8,b]         A[7,a],[5,b]  -->   A[4,a],[5,a]A[8,a],[5,b]&#10;A[7,b]     -->   A[4,b],[5,a]A[8,a]                   -->   A[4,a],[5,b]A[8,b],[5,b]&#10;          -->   A[4,b],[5,b]A[8,b]         A[7,b],[5,a]  -->   A[4,b],[5,a]A[8,a],[5,a]&#10;A[8,b]     -->   A[4,b]                           -->   A[4,b],[5,b]A[8,b],[5,a]&#10;A[4,a],[5,a] -->   A[5,a],[5,a]             A[7,b],[5,b]  -->   A[4,b],[5,a]A[8,a],[5,b]&#10;          -->   A[6,a],[5,a]                       -->   A[4,b],[5,b]A[8,b],[5,b]&#10;A[4,a],[5,b]  -->   A[5,a],[5,b]             A[8,b],[5,a]  -->   A[4,b],[5,a]&#10;          -->   A[6,a],[5,b]             A[8,b],[5,b]  -->   A[4,b],[5,b]" 
      src="theory-bk-threese3_files/theory-bk-three37x.gif"> </DIV>(b) <A 
      name=40003-19006r3.3.5>&nbsp;</A> <BR>
      <TABLE>
        <TBODY>
        <TR vAlign=baseline>
          <TD><NOBR><STRONG>Figure 3.3.5</STRONG></NOBR></TD>
          <TD>The grammar in (b) generates the language accepted by the 
            program in (a). </TD></TR></TBODY></TABLE>
      <CENTER></CENTER></TD></TR></TBODY></TABLE></CENTER>
<HR>

<P>L(P) is generated by the grammar G, which has the production rules in 
Figure&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-19006r3.3.5">3.3.5</A>(b). 
[i, x] denotes a state of P that corresponds to the instruction segment 
I<SUB>i</SUB>, and value x in <TT>x</TT>. 
<P>The derivation tree for the string abb in the grammar G, and the 
corresponding transitions between the states of the program P on input "a, b, 
b", are shown in Figure&nbsp;<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html#40003-19007r3.3.6">3.3.6</A>. 
The symbol A<SUB>[1,a]</SUB> states that the computation of P has to start at 
state [1, a] and end at an accepting state. The production rule 
A<SUB>[1,a]</SUB> <IMG alt="-->" src="theory-bk-threese3_files/cmsy10-21.gif"> 
A<SUB>[4,a][5,b]</SUB>A<SUB>[2,b]</SUB> corresponds to a call to f which returns 
the value b. <IMG alt=" *** " 
src="theory-bk-threese3_files/theory-bk-three1x.gif"> 
<P>
<HR>

<CENTER>
<TABLE>
  <TBODY>
  <TR>
    <TD><A name=40003-19007r3.3.6>&nbsp;</A> <A 
      name=40003-19007r3.3.6>&nbsp;</A> <BR><IMG alt=[PICT] 
      src="theory-bk-threese3_files/theory-bk-three-3-3-6.jpg"> <BR>
      <TABLE>
        <TBODY>
        <TR vAlign=baseline>
          <TD><NOBR><STRONG>Figure 3.3.6</STRONG></NOBR></TD>
          <TD>A correspondence between a derivation tree and a computation of 
            a recursive finite-domain program. </TD></TR></TBODY></TABLE>
      <CENTER></CENTER></TD></TR></TBODY></TABLE></CENTER>
<HR>

<P>Context-free grammars do not resemble pushdown automata, the way Type 3 
grammars resemble finite-state automata. The difference arises because 
derivations in context-free grammars are recursive in nature, whereas 
computations of pushdown automata are iterative. 
<P>Consequently, some context-free languages can be more easily characterized by 
context-free grammars, and other context-free languages can be more easily 
characterized by pushdown automata.<A name=40003-19008> </A>
<P>
<P>[<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese4.html">next</A>] 
[<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese2.html">prev</A>] 
[<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese2.html#tailtheory-bk-threese2.html">prev-tail</A>] 
[<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-threese3.html">front</A>] 
[<A 
href="http://www.cse.ohio-state.edu/~gurari/theory-bk/theory-bk-three.html#theory-bk-threese3.html">up</A>] 
<A name=tailtheory-bk-threese3.html>&nbsp;</A></P></BODY></HTML>
