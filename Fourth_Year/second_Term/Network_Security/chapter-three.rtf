{\rtf1\ansi\ansicpg1256
{\fonttbl
{\f1\fswiss\fcharset0\fprq0 Verdana;}
{\f2\fswiss\fcharset0\fprq0 Arial;}
{\f3\fnil\fcharset2\fprq0 Monotype Sorts;}
}
{\colortbl;
\red0\green0\blue0;
}
{\stylesheet
{\s1\qc\f1\fs32\ppscheme26113\lang1025\level1 heading 1;}
{\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025\level2 heading 2;}
{\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025\level3 heading 3;}
{\s4\li725\fi-141\qj\f1\fs16\ppscheme-1\lang1025\level4 heading 4;}
{\s5\li948\fi-133\qj\f1\fs18\ppscheme-1\lang1025\level5 heading 5;}
{\s6\li1172\fi-133\qj\f1\fs18\ppscheme-1\lang1025\level6 heading 6;}
}
\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs48\lang1033 Security  }{\f1\fs48\lang1033   \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\lang1033 Crypto Basics \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Why?\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Cryptographic Protocols!\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Terminology\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\lang1033 Encryption and Decryption\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang2057 Definition}{\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs24\ppscheme3368449\lang1033 Understanding physical }{\f1\fs28\lang2057 cryptography}{\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Substitution ciphers-1 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Substitution ciphers-2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Substitution ciphers-2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Transposition ciphers-1 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Transposition ciphers-2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 The German Enigma cipher machine \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs24\ppscheme3368449\lang1033 Understanding mathematical }{\f1\fs28\lang2057 cryptography-1}{\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs24\ppscheme3368449\lang1033 Understanding mathematical }{\f1\fs28\lang2057 cryptography-2}{\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs28\lang1033 XOR what?\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs28\lang1033 Breaking Ciphers-1\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs28\lang1033 Breaking Ciphers-2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs28\lang1033 Breaking Ciphers-3\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang2057 Types of attacks}{\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs28\lang1033 Cryptosystems-1\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs28\lang1033 Cryptosystems-2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs20\lang1033 Encrypting and Decrypting Data with Symmetric Keys-1}{\f1\fs20\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs20\lang1033 Encrypting and Decrypting Data with Symmetric Keys-2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs24\lang1033 Symmetric Keys-3\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Types of Attacks on Encrypted Messages \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Stream Ciphers and Block Ciphers \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Example\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Example\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Stream Cipher Structure \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Symmetric Algorithms-1 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Symmetric key crypto: DES}{\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Symmetric key \line crypto: DES}{\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Symmetric Algorithms-2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Symmetric Algorithms-3\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Symmetric Algorithms-4\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Algorithm Parameters-1\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Algorithm Parameters-2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs24\lang1033 Symmetric Key Encryption in .NET}{\b\f1\fs28\lang1033  }{\f1\fs28\lang1033  \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 1\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 3\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs28\lang1033 Symmetric Algorithm Classes in the .NET -1 }{\f1\fs28\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs28\lang1033 Symmetric Algorithm Classes in the .NET -2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs28\lang1033 Symmetric Algorithm Classes in the .NET -3\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs24\lang1033 How to Encrypt and Decrypt Messages Using Symmetric Keys}{\f1\fs24\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 1\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\f1\fs28\lang1033 Example\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs28\lang1033 Lab \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\fs28\lang1033 Illustrates encrypting a string -1\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 3\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 4\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\lang1033 Encrypting Files\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 1\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\b\f1\lang1033 Decrypting Files\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 1\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 2\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs24\lang1033 Friends and enemies: Alice, Bob, Trudy}{\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\lang1033 Who might Bob, Alice be?\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs24\lang1033 There are bad guys (and girls) out there!\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 The language of cryptography}{\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Symmetric key cryptography}{\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Symmetric key cryptography}{\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Public Key Cryptography}{\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Public key cryptography}{\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Public key encryption algorithms}{\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs24\lang1033 Applications for Public-Key Cryptosystems}{\f1\lang1033  \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\f1\fs18 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs18\pnscheme26113{\pntxtb \'bb}}{\f1\lang1033 Bob creates a pair of keys, one of which he keeps secret and one of which he sends to Alice.\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\f1\fs18 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs18\pnscheme26113{\pntxtb \'bb}}{\f1\lang1033 Alice composes a confidential message and encrypts it using the key that Bob has sent to her.\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\f1\fs18 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs18\pnscheme26113{\pntxtb \'bb}}{\f1\lang1033 Alice sends the encrypted data to Bob.\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\f1\fs18 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs18\pnscheme26113{\pntxtb \'bb}}{\f1\lang1033 Bob uses his secret key to decrypt the data and reads the confidential message.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The key that Bob sends to Alice is the public key, and the key he keeps to himself is the "private" key; jointly, they form Bob's "key pair."\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The most striking aspect of asymmetric encryption is that Alice is not involved in selecting the key: Bob creates a pair of keys without any input or agreement from Alice and simply sends her the public key. Bob retains the private key and keeps it secret. Alice uses an asymmetric algorithm to encrypt a message with Bob's public key and sends him the encrypted data, which he decrypts using the private key.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 Asymmetric algorithms include a }{\f1 "}{\f1\lang1033 key generation}{\f1 " }{\f1\lang1033 protocol that Bob uses to create his key pair. Following the protocol results in the creation of a pair of keys that have a mathematical relationship\'97the exact detail of the protocol and the relationship between the keys is different for each algorithm.\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 When we talk about an asymmetric encryption algorithm, we are actually referring to two related functions that perform specific tasks: an encryption function that encrypts a message using a public key, and a decryption function that uses a secret key to decrypt a message encrypted with the corresponding public key.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The encryption function can only encrypt data. Alice cannot decrypt }{\f1\lang1033 ciphertext}{\f1\lang1033  that she has created using the encryption function. This means that Bob can send his public key to several people, and each of them can create }{\f1\lang1033 ciphertext}{\f1\lang1033  that only Bob's secret key can decrypt.\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 The one}{\f1\fs18 -}{\f1\fs18\lang1033 way nature of the encryption function means that messages created by one sender cannot be read by another }{\f1\fs18 (}{\f1\fs18\lang1033 i}{\f1\fs18 .}{\f1\fs18\lang1033 e}{\f1\fs18 .}{\f1\fs18\lang1033 , Alice cannot decrypt the }{\f1\fs18\lang1033 ciphertext}{\f1\fs18\lang1033  that Anthony has created, even though they both have Bob's public key}{\f1\fs18 ). }{\f1\fs18\lang1033 Bob can give out the public key to anyone who wants to send him a message, and he can even print his public key on his business card and hand it out to anyone who might want to send him a message}{\f1\fs18 . }{\f1\fs18\lang1033 He can add the public key to an Internet directory of keys, allowing people Bob has never met to create messages that only he can read}{\f1\fs18 .}{\f1\fs18\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 If Bob suspects that Eve has guessed his private key, he simply creates a new key pair and sends out the new public key to anyone who might send him a message. This is a lot easier than arranging to meet in a secure location to agree on a new symmetric secret key with every person that might want to communicate with him. \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 Bob's pair of keys allows Alice to send him encrypted messages, but Bob cannot use them to send a message back to Alice because of the one-way nature of the encryption and decryption functions. If Bob needs to send Alice a confidential message, Alice must create her own pair of keys and send the public key to Bob, who can then use the encryption function to create }{\f1\fs18\lang1033 ciphertext}{\f1\fs18\lang1033  that only Alice can decrypt with her private key.\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The main limitation of public key encryption is that it is very slow relative to symmetric encryption and is not practical for encrypting large amounts of data}{\f1 . }{\f1\lang1033 In fact, the most common use of public key encryption is to solve the key agreement problem for symmetric encryption algorithms.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 In the following sections, we demonstrate how an asymmetric encryption algorithm works. We use the RSA algorithm for our illustration because it is the only one implemented in the .NET Framework. Ronald }{\f1\lang1033 Rivest}{\f1\lang1033 , }{\f1\lang1033 Adi}{\f1\lang1033  }{\f1\lang1033 Shamir}{\f1\lang1033 , and Leonard }{\f1\lang1033 Adleman}{\f1\lang1033  created the RSA algorithm in 1977, and the name is the first letter of each of the inventors' last names. The RSA algorithm is the basis for numerous security systems, and remains the most widely used and understood asymmetric algorithm.\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Creating Asymmetric Keys }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 Most asymmetric algorithms use keys that are very large numbers, and the RSA algorithm is no exception. \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 We step through the RSA key generation protocol, using small test values. The protocol is as follows:}{\b\f1\fs18\lang1033 \par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\f1\fs16 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs16\pnscheme26113{\pntxtb \'bb}}{\f1\fs16\lang1033 Choose two large random prime numbers, p and q, of equal length and multiply them together to create n, the RSA key modulus.\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\f1\fs16 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs16\pnscheme26113{\pntxtb \'bb}}{\f1\fs16\lang1033 Select p as 23 and q as 31, so that the modulus, n, is:\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\f1\fs16 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs16\pnscheme26113{\pntxtb \'bb}}{\f1\fs16\lang1033 n = p x q = 23 x 31 = 713}{\b\f1\fs16\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 Randomly choose e, the public exponent, so that e and (p - 1)(q - 1) are relatively }{\f1\fs18\lang1033 prime.Numbers}{\f1\fs18\lang1033  are "relatively" prime when they share no common factors except 1. For these test values   select a value for }{\i\f1\fs18\lang1033 e}{\f1\fs18\lang1033  that has no common factors with 660. Select e as 19.}{\b\f1\fs18\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 Compute the private exponent, d, where d = e}{\f1\fs18\super\lang1033 -1}{\f1\fs18\lang1033 mod((p - 1)(q - 1)).\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\plain\f1\fs16 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs16\pnscheme26113{\pntxtb \'bb}}{\f1\fs16\lang1033 For our example, we calculate d as follows:\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\plain\f1\fs16 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs16\pnscheme26113{\pntxtb \'bb}}{\f1\fs16\lang1033 d = 19}{\f1\fs16\super\lang1033 -1 }{\f1\fs16\lang1033 mod(22 x 30) = 139}{\b\f1\fs16\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 The public key consists of e and n. The private key is d. Discard p and q, but do not reveal their values.}{\b\f1\fs18\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 You can see how simple it is to create an RSA key pair. Bob sends the value of e (19) and n (713) to Alice and keeps the value of d (139) secret. Most asymmetric encryption algorithms use a similar approach to key generation.\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Asymmetric Algorithm Security }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 Asymmetric algorithms use much longer keys than symmetric algorithms. In our examples, we selected small values to demonstrate the key generation protocol, but the numeric values used in practice contain many hundreds of digits.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 Measure asymmetric key lengths in bits. The way to determine the number of bits differs between algorithms. The RSA algorithm specifies that the key length is the smallest number of bits needed to represent the value of the key modulus, }{\i\f1\fs18\lang1033 n}{\f1\fs18\lang1033 , using binary. Round up the number of bits to a factor of eight so that you can express the key using bytes; for example, consider a modulus represented by 509 bits to be a 512-bit key. Common lengths for keys are 512 and 1024-bits, but a 1024-bit asymmetric key does not provide 16 times more resistance to attack than a 64-bit symmetric key.}{\loch\af1\fs18\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 Most asymmetric algorithms rely on some form mathematical task that is difficult or time}{\f1\fs18 -}{\f1\fs18\lang1033 consuming to perform}{\f1\fs18 . }{\f1\fs18\lang1033 Cryptographers consider the RSA algorithm secure because it is hard to find the factors of a large number; given our example value for n (713), it would take some time to establish that the factors are the values you selected for p (23) and q (31). The longer the value of n, the longer it takes to determine the factors.}{\f1\fs18 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Creating the Encrypted Data }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Asymmetric data padding }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 Asymmetric encryption algorithms rely on padding to protect against specific kinds of attack, in much the same way that symmetric algorithms rely on cipher feedback. Padding schemes also ensure that the encryption function does not have to process partial blocks of data.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 Asymmetric padding schemes are a series of instructions that specify how to prepare data before encryption, and usually mix the plaintext with other data to create a }{\f1\lang1033 ciphertext}{\f1\lang1033  that is much larger than the original message.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The .NET Framework supports two padding schemes for the RSA algorithm: Optimal Asymmetric Encryption Padding (OAEP) and PKCS #1 v1.5. OAEP is a newer scheme that provides protection from attacks to which the PKCS #1 v1.5 scheme is susceptible. You should always use OAEP, unless you need to exchange encrypted data with a legacy application that expects PKCS #1 v1.5 padding.\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Programming Asymmetrical Encryption }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The }{\f1 .}{\f1\lang1033 NET Framework takes the same approach to representing asymmetric algorithms as it does for symmetric algorithms and hashing algorithms; abstract classes extend the }{\f1\lang1033 System.Security.Cryptography.AsymmetricAlgorithm}{\f1\lang1033  class for each of the supported algorithms. Individual implementations of the algorithms extend the abstract class, supporting the possibility of more than one implementation of an algorithm .\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 The }{\f1\fs28\lang1033 AsymmetricAlgorithm}{\f1\fs28\lang1033  class }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 The RSA class }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The RSA class is the abstract representation of the RSA algorithm and extends }{\f1\lang1033 AsymmetricAlgorithm}{\f1\lang1033 . This class provides the common functionality shared by any implementation of the underlying algorithm and allows the algorithm to be employed without regard to the implementation details.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The }{\f1\lang1033 EncryptValue}{\f1\lang1033  and }{\f1\lang1033 DecryptValue}{\f1\lang1033  methods are not as useful as they seem, as we will explain in the next section. The value of the RSA class is the addition of the }{\f1\lang1033 ImportParameters}{\f1\lang1033  and }{\f1\lang1033 ExportParameters}{\f1\lang1033  methods, which allow the public or private keys to be imported into or exported from an instance of the class.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 The }{\f1\fs28\lang1033 RSACryptoServiceProvider}{\f1\fs28\lang1033  Class }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 This class is the only asymmetric encryption implementation class contained in the .NET Framework. Unfortunately, while this class extends the abstract RSA class, it does not implement the }{\f1\lang1033 EncryptValue}{\f1\lang1033  and }{\f1\lang1033 DecryptValue}{\f1\lang1033  methods, meaning that you must work with the implementation class directly to use the RSA algorithm. \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Using RSA Keys }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs13 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs13\pnscheme154{\pntxtb n}}{\f1\fs17\lang1033 Even though you cannot use the abstract classes to encrypt and decrypt data, the methods that they define do allow you to configure the keys used by instances of the }{\f1\fs17\lang1033 RSACryptoServiceProvider}{\f1\fs17\lang1033  class.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs13 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs13\pnscheme154{\pntxtb n}}{\f1\fs17\lang1033 The }{\f1\fs17\lang1033 AsymmetricAlgorithm}{\f1\fs17\lang1033  class provides the }{\f1\fs17\lang1033 LegalKeySizes}{\f1\fs17\lang1033  property, which returns an array of the }{\f1\fs17\lang1033 KeySizes}{\f1\fs17\lang1033  structure, specifying all of the key lengths that the algorithm supports. \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs13 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs13\pnscheme154{\pntxtb n}}{\f1\fs17\lang1033 The .NET RSA implementation supports key lengths from 384 to 16384 bits, in 8-bit steps, and the size of key you wish to use is set using the }{\f1\fs17\lang1033 KeySize}{\f1\fs17\lang1033  property.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs13 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs13\pnscheme154{\pntxtb n}}{\f1\fs17\lang1033 The RSA implementation will create a new key pair automatically if you have not imported a key value before you encrypt or decrypt data. You can export the details of this key using the }{\f1\fs17\lang1033 ExportParameters}{\f1\fs17\lang1033  method, which returns an instance of the }{\f1\fs17\lang1033 RSAParameters}{\f1\fs17\lang1033  structure. This method accepts a Boolean argument. If the argument is true, then the private key is exported; otherwise, only the details of the public key are included:\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs17\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs12 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs12\pnscheme154{\pntxtb n}}{\b\f1\fs16\lang1033 RSACryptoServiceProvider}{\b\f1\fs16\lang1033  }{\b\f1\fs16\lang1033 x_alg}{\b\f1\fs16\lang1033  }{\b\f1\fs16 = }{\b\f1\fs16\lang1033 new }{\b\f1\fs16\lang1033 RSACryptoServiceProvider}{\b\f1\fs16 (  )}{\b\f1\fs16\lang1033 ;\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs12 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs12\pnscheme154{\pntxtb n}}{\b\f1\fs16 // }{\b\f1\fs16\lang1033 export only the public key \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs12 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs12\pnscheme154{\pntxtb n}}{\b\f1\fs16\lang1033 RSAParameters}{\b\f1\fs16\lang1033  }{\b\f1\fs16\lang1033 x_public_params}{\b\f1\fs16\lang1033  }{\b\f1\fs16 = }{\b\f1\fs16\lang1033 x_alg}{\b\f1\fs16 .}{\b\f1\fs16\lang1033 ExportParameters}{\b\f1\fs16 (}{\b\f1\fs16\lang1033 false}{\b\f1\fs16 )}{\b\f1\fs16\lang1033 ;\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs12 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs12\pnscheme154{\pntxtb n}}{\b\f1\fs16 // }{\b\f1\fs16\lang1033 export the private key \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs12 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs12\pnscheme154{\pntxtb n}}{\b\f1\fs16\lang1033 RSAParameters}{\b\f1\fs16\lang1033  }{\b\f1\fs16\lang1033 x_private_params}{\b\f1\fs16\lang1033  }{\b\f1\fs16 = }{\b\f1\fs16\lang1033 x_alg}{\b\f1\fs16 .}{\b\f1\fs16\lang1033 ExportParameters}{\b\f1\fs16 (}{\b\f1\fs16\lang1033 true}{\b\f1\fs16 )}{\b\f1\fs16\lang1033 ;\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The most common use for the }{\f1\lang1033 ExportParameters}{\f1\lang1033  method is to export details of a key from one instance of an algorithm and then import them to another using the }{\f1\lang1033 ImportParameters}{\f1\lang1033  method:\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\lang1033 // create an instance of the RSA algorithm\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025\ql {\f1\lang1033 RSACryptoServiceProvider}{\f1\lang1033  }{\f1\lang1033 x_alg}{\f1\lang1033  = new }{\f1\lang1033 RSACryptoServiceProvider}{\f1\lang1033 (  );\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025\ql {\f1\lang1033 // export only the public key \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025\ql {\f1\lang1033 RSAParameters}{\f1\lang1033  }{\f1\lang1033 x_public_params}{\f1\lang1033  = }{\f1\lang1033 x_alg.ExportParameters(false}{\f1\lang1033 );\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025\ql {\f1\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025\ql {\f1\lang1033 // create a second instance of the algorithm\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025\ql {\f1\lang1033 RSACryptoServiceProvider}{\f1\lang1033  }{\f1\lang1033 x_second_algorithm}{\f1\lang1033  = new }{\f1\lang1033 RSACryptoServiceProvider}{\f1\lang1033 (  );\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025\ql {\f1\lang1033 // import the public key\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025\ql {\f1\lang1033 x_second_algorithm.ImportParameters(x_public_params}{\f1\lang1033 );\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 The }{\f1\fs18\lang1033 RSAParameters}{\f1\fs18\lang1033  structure is also useful if you need to export a key into a custom format}{\f1\fs18 . }{\f1\fs18\lang1033 The following statements demonstrate how to export the public part of a key pair and write it out as a pair of hexadecimal strings}{\f1\fs18 :\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\loch\af1\fs18\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18 // }{\f1\fs18\lang1033 create an instance of the RSA algorithm}{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033 RSACryptoServiceProvider}{\f1\fs18\lang1033  }{\f1\fs18\lang1033 x_alg}{\f1\fs18\lang1033  }{\f1\fs18 = }{\f1\fs18\lang1033 new }{\f1\fs18\lang1033 RSACryptoServiceProvider}{\f1\fs18 (  )}{\f1\fs18\lang1033 ;}{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18 // }{\f1\fs18\lang1033 export only the public key }{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033 RSAParameters}{\f1\fs18\lang1033  }{\f1\fs18\lang1033 x_public_params}{\f1\fs18\lang1033  }{\f1\fs18 = }{\f1\fs18\lang1033 x_alg}{\f1\fs18 .}{\f1\fs18\lang1033 ExportParameters}{\f1\fs18 (}{\f1\fs18\lang1033 false}{\f1\fs18 )}{\f1\fs18\lang1033 ;}{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033 Console}{\f1\fs18 .}{\f1\fs18\lang1033 Write}{\f1\fs18 ("}{\f1\fs18\lang1033 n}{\f1\fs18 : ")}{\f1\fs18\lang1033 ;}{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033 foreach}{\f1\fs18\lang1033  }{\f1\fs18 (}{\f1\fs18\lang1033 byte }{\f1\fs18\lang1033 x_byte}{\f1\fs18\lang1033  in }{\f1\fs18\lang1033 x_public_params}{\f1\fs18 .}{\f1\fs18\lang1033 Modulus}{\f1\fs18 ) }{\f1\fs18\lang1033 \'7b}{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033     Console}{\f1\fs18 .}{\f1\fs18\lang1033 Write}{\f1\fs18 ("}{\f1\fs18\lang1033 \'7b0}{\f1\fs18 :}{\f1\fs18\lang1033 X2\'7d }{\f1\fs18 "}{\f1\fs18\lang1033 , }{\f1\fs18\lang1033 x_byte}{\f1\fs18 )}{\f1\fs18\lang1033 ;}{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033 \'7d}{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033 Console}{\f1\fs18 .}{\f1\fs18\lang1033 WriteLine}{\f1\fs18 (  )}{\f1\fs18\lang1033 ;}{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033 Console}{\f1\fs18 .}{\f1\fs18\lang1033 Write}{\f1\fs18 ("}{\f1\fs18\lang1033 e}{\f1\fs18 : ")}{\f1\fs18\lang1033 ;}{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033 foreach}{\f1\fs18\lang1033  }{\f1\fs18 (}{\f1\fs18\lang1033 byte }{\f1\fs18\lang1033 x_byte}{\f1\fs18\lang1033  in }{\f1\fs18\lang1033 x_public_params}{\f1\fs18 .}{\f1\fs18\lang1033 Exponent}{\f1\fs18 ) }{\f1\fs18\lang1033 \'7b}{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033     Console}{\f1\fs18 .}{\f1\fs18\lang1033 Write}{\f1\fs18 ("}{\f1\fs18\lang1033 \'7b0}{\f1\fs18 :}{\f1\fs18\lang1033 X2\'7d }{\f1\fs18 "}{\f1\fs18\lang1033 , }{\f1\fs18\lang1033 x_byte}{\f1\fs18 )}{\f1\fs18\lang1033 ;}{\f1\fs18 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033 \'7d}{\f1\fs18 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Encrypting and Decrypting Data }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 The }{\f1\fs18\lang1033 RSACryptoServiceProvider}{\f1\fs18\lang1033  class defines the Encrypt and Decrypt methods, each of which processes a byte array, as demonstrated by the following statements:\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Exchange Symmetric Session Keys Securely }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The }{\f1 .}{\f1\lang1033 NET Framework class library includes support for key exchange using only the RSA algorithm, but you must choose between two formatting schemes}{\f1 : }{\f1\lang1033 Optimal Asymmetric Encryption Padding }{\f1 (}{\f1\lang1033 OAEP}{\f1 ) }{\f1\lang1033 and PKCS #1. \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The following two classes implement the key exchange mechanism\'97one for each formatting scheme:\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\i\f1\lang1033 System.Security.Cryptography.RSAOAEPKeyExchangeFormatter}{\f1\lang1033  \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\i\f1\lang1033 System.Security.Cryptography.RSAPKCS1KeyExchangeFormatter}{\f1\lang1033  \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 To prepare a symmetric key for exchange you must create a formatter object of the desired type and then assign an asymmetric algorithm object (}{\i\f1\lang1033 RSACryptoServiceProvider}{\f1\lang1033 ) to the formatter by calling the formatter's }{\i\f1\lang1033 SetKey}{\f1\lang1033  method. You must configure the asymmetric algorithm to use the recipient's public key. Once configured, call the formatter's }{\i\f1\lang1033 CreateKeyExchange}{\f1\lang1033  method and pass a }{\i\f1\lang1033 byte}{\f1\lang1033  array containing the symmetric session key that you want to format. The }{\i\f1\lang1033 CreateKeyExchange}{\f1\lang1033  method returns a }{\i\f1\lang1033 byte}{\f1\lang1033  array containing the key exchange data that you should send to the intended recipient.\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 Deformatting}{\f1\lang1033  the exchanged key mirrors the formatting process}{\f1 . }{\f1\lang1033 There are two }{\f1\lang1033 deformatter}{\f1\lang1033  classes\'97one for each formatting scheme}{\f1 .}{\f1\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\i\f1\fs18\lang1033 System.Security.Cryptography.RSAOAEPKeyExchangeDeformatter}{\f1\fs18\lang1033  \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\i\f1\fs18\lang1033 System.Security.Cryptography.RSAPKCS1KeyExchangeDeformatter}{\f1\lang1033  \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 To }{\f1\lang1033 deformat}{\f1\lang1033  a formatted session key, create a }{\f1\lang1033 deformatter}{\f1\lang1033  object of the appropriate type and call its }{\i\f1\lang1033 SetKey}{\f1\lang1033  method to assign an asymmetric algorithm object. You must load your private key into the asymmetric algorithm. Finally, call the }{\i\f1\lang1033 DecryptKeyExchange}{\f1\lang1033  method passing in the key exchange data. The }{\i\f1\lang1033 DecryptKeyExchange}{\f1\lang1033  method returns a }{\i\f1\lang1033 byte}{\f1\lang1033  array containing the original symmetric session key.\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The }{\i\f1\lang1033 Main}{\f1\lang1033  method then calls the example's }{\i\f1\lang1033 FormatKeyExchange}{\f1\lang1033  method passing a }{\i\f1\lang1033 byte}{\f1\lang1033  array containing the symmetric key and an }{\i\f1\lang1033 RSAParameters}{\f1\lang1033  object containing the recipient's public key. The }{\i\f1\lang1033 FormatKeyExchange}{\f1\lang1033  method returns a }{\i\f1\lang1033 byte}{\f1\lang1033  array containing the encrypted and formatted symmetric key, ready to send to the intended recipient. Next the }{\i\f1\lang1033 Main}{\f1\lang1033  method calls the example's }{\i\f1\lang1033 DeformatKeyExchange}{\f1\lang1033  method passing the formatted key exchange data and a }{\i\f1\lang1033 CspParameters}{\f1\lang1033  object that contains a reference to the }{\i\f1\lang1033 MyKeys}{\f1\lang1033  key container, which contains the recipient's private key. During the process, the }{\i\f1\lang1033 Main}{\f1\lang1033  method displays the original session key, the formatted exchange data, and finally the }{\f1\lang1033 deformatted}{\f1\lang1033  session key.\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Digital Signatures }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 You use an asymmetric key pair to create a "signature" for a message by adding a signature function to the asymmetric algorithm. The recipient can verify the signature using a verification function. Asymmetric algorithms that support signature and verification functions are digital signature algorithms. Each digital signature is specific to an individual message or document, and if Alice signs a message, Bob can be confident that Eve has not sent him a forgery.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\lang1033 \par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\plain\f1\fs18 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs18\pnscheme26113{\pntxtb \'bb}}{\f1\lang1033 Alice selects an asymmetric signature algorithm and follows the key generation protocol to create a new pair of keys. She keeps her private key secret and sends the public key to Bob.\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\plain\f1\fs18 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs18\pnscheme26113{\pntxtb \'bb}}{\f1\lang1033 Alice composes a message and creates a signature using her private key.\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\plain\f1\fs18 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs18\pnscheme26113{\pntxtb \'bb}}{\f1\lang1033 Alice sends the message and the signature to Bob.\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\plain\f1\fs18 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs18\pnscheme26113{\pntxtb \'bb}}{\f1\lang1033 Bob uses Alice's public key to verify the signature. If the signature is valid, Bob can be confident that:\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\plain\f1\fs18 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs18\pnscheme26113{\pntxtb \'bb}}{\f1\lang1033 Alice is truly the author of the message.\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\plain\f1\fs18 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs18\pnscheme26113{\pntxtb \'bb}}{\f1\lang1033 Eve has not altered the message contents.\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 Notice that Alice, the sender of the message, creates the key pair and retains the private key; this is different from asymmetric encryption, where the recipient }{\f1\fs18 (}{\f1\fs18\lang1033 Bob}{\f1\fs18 ) }{\f1\fs18\lang1033 is responsible for key creation}{\f1\fs18 . }{\f1\fs18\lang1033 Digitally signing a message creates a separate piece of data, which Alice sends to Bob along with the message}{\f1\fs18 .}{\f1\fs18\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 The relatively slow performance of asymmetric algorithms means that Alice does not sign the entire message she wants to send; instead, she creates a cryptographic hash code for the message and signs this instead. Subject to the limitations of hash code security , signing hash code for a message is equivalent to signing the message itself, but is much faster, because the hash code is less data to process with the asymmetric algorithm\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 Bob verifies the signature by creating his own hash code and using the asymmetric signature verification and Alice's public key}{\f1\fs18 . }{\f1\fs18\lang1033 Bob cannot verify the signature if the message is altered in any way, meaning that Eve cannot secretly tamper with the contents and Bob cannot alter a message and later claim that Alice had signed the altered version}{\f1\fs18 . }{\f1\fs18\lang1033 Alice and Bob must use the same hash code algorithm; otherwise, Bob will not be able to verify valid signatures}{\f1\fs18 .}{\f1\fs18\lang1033  \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\loch\af1\fs28\ppscheme3368449\lang3073 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 Digital Signature Security }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 Digital signatures have two objectives: they must be cryptographically secure and they must provide equivalent security features to an ink signature on a printed document. We summarize the security features of digital signatures as follows:\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\f1\fs16 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs16\pnscheme26113{\pntxtb \'bb}}{\f1\fs16\lang1033 Eve should not be able to forge Alice's digital signature. Eve cannot create a fake signature unless she knows Alice's private key; as in almost all aspects of cryptography, digital signatures rely on the careful protection and management of keys. If Eve could forge Alice's signature, Eve could make it appear that Alice has signed any document.\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\f1\fs16 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs16\pnscheme26113{\pntxtb \'bb}}{\f1\fs16\lang1033 Eve should not be able to reuse one of Alice's digital signatures. Eve can only take Alice's signature from one document and associate it with another if both documents produce the same data hash code.  \par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\f1\fs16 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs16\pnscheme26113{\pntxtb \'bb}}{\f1\fs16\lang1033 Eve should not be able to alter a signed document. If Eve alters the content of a document, then Alice's signature will no longer be valid, because the altered document will produce a different data hash code to the one that Alice signed. Eve could alter a document successfully if it resulted in the same data hash code as the original (which is, in effect, the same as reusing Alice's signature).\par 
}\pard\plain\ltrpar\s3\li493\fi-177\qj\f1\fs18\ppscheme-1\lang1025 {\pntext\pard\f1\fs16 \'bb\tab}{\*\pn\pnlvlblt\pnf1\pnfs16\pnscheme26113{\pntxtb \'bb}}{\f1\fs16\lang1033 Alice should not be able to deny that she has signed a document. Alice cannot sign a document and then later claim that she did not, because we assume that she is the only person who knows her secret key. If she suspects that her key has been compromised, then she must create a new key pair\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\lang1033 The }{\f1\fs28\lang3073 .}{\f1\fs28\lang1033 NET Framework Digital Signature Algorithms }{\f1\fs28\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The }{\f1 .}{\f1\lang1033 NET Framework includes two asymmetric algorithms that support digital signatures, one is the RSA algorithm; this algorithm defines functions for both data encryption and digital signatures.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs15 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs15\pnscheme154{\pntxtb n}}{\f1\lang1033 The second algorithm is the Digital Signature Algorithm (DSA), published as a U.S. FIPS in May 1994. DSA supports digital signatures but not data encryption. Initially created to provide a standard algorithm for digital signatures for federal projects, DSA has gained support in commercial projects gradually but still lags behind RSA in terms of adoption.\par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs24\lang1033 Programming Digital Signatures}{\f1\lang1033  }{\f1\lang3073 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\f1\fs18\lang1033 The .NET Framework groups encryption and digital signature algorithms together as subclasses of the }{\f1\fs18\lang1033 AsymmetricAlgorithm}{\f1\fs18\lang1033  class. The following figure depicts the .NET class hierarchy for digital signature algorithms, which differs from the encryption algorithm hierarchy only because of the addition of the signature-only DSA support.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\fs18\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs24\lang1033 Using the Implementation Class}{\f1\lang1033  \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs28\ppscheme3368449\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\b\f1\fs18\lang1033 The }{\b\f1\fs18\lang1033 SignData}{\b\f1\fs18\lang1033  method creates a signature by generating a hash code, formatting the hash code using PKCS #1, and signing the result. The corresponding }{\b\f1\fs18\lang1033 VerifyData}{\b\f1\fs18\lang1033  method creates a PKCS #1-formatted hash code and uses it to verify a signature.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\b\f1\fs18\lang1033 For the RSA algorithm, the hash codes are generated using an instance of System.Security.Cryptography.HashAlgorithm, provided as an argument to the }{\b\f1\fs18\lang1033 SignData}{\b\f1\fs18\lang1033  and }{\b\f1\fs18\lang1033 VerifyData}{\b\f1\fs18\lang1033  methods. For the DSA algorithm, the SHA-1 hashing algorithm is always used to generate the hash codes.\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\pntext\pard\plain\f3\fs14 n\tab}{\*\pn\pnlvlblt\pnf3\pnfs14\pnscheme154{\pntxtb n}}{\b\f1\fs18\lang1033 The following statements demonstrate how to use the }{\b\f1\fs18\lang1033 SignData}{\b\f1\fs18\lang1033  method to create a signature for a byte array, and then verify the signature using the }{\b\f1\fs18\lang1033 VerifyData}{\b\f1\fs18\lang1033  method:\par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\b\f1\fs18\lang1033 \par 
}\pard\plain\ltrpar\s2\li226\fi-226\qj\f1\fs20\ppscheme-1\lang1025 {\f1\lang1033 \par 
}\pard\plain\ltrpar\s1\qc\f1\fs32\ppscheme26113\lang1025 {\f1\fs24\ppscheme3368449\lang1033 Example\par 
}
}