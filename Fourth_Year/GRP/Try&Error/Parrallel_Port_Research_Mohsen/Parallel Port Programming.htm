<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0054)http://www.gmonline.demon.co.uk/cscene/CS4/CS4-02.html -->
<HTML><HEAD><TITLE>Parallel Port Programming</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1256">
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY text=#000000 vLink=#441a8b aLink=#ff0000 link=#0000ee bgColor=#ffffff><PRE>
==============================================================================
<A href="http://www.gmonline.demon.co.uk/cscene/CS4/CS4-01.html">C Scene Issue #04</A>
Parallel Port Programming
<A href="http://www.gmonline.demon.co.uk/cscene/people/elzubeir.html">Moe Elzubeir</A>
=============================================================================
</PRE><FONT face=times size=+1>
<P>Parallel port programming is easier than it sounds. The lack of literature on 
it is surprising, but not a problem. Once you find a few resources of 
information, you will be set. In this article, I will try to give you the inform 
ation that you need, without the baffling technicality. Simple does it.</P>
<P>&nbsp;</P>
<P>&nbsp;</P><I><U>
<P>The Basics:</P></I></U>
<P>Access to the parallel port is via a female DB25 on the back of the PC.</P>
<P>&nbsp;</P></FONT>
<TABLE cellSpacing=1 cellPadding=7 width=590 border=1>
  <TBODY>
  <TR>
    <TD vAlign=top width="33%"><B><I><FONT size=2>
      <P align=center>Pin</B></I></FONT></P></TD>
    <TD vAlign=top width="33%"><B><I><FONT size=2>
      <P align=center>Description</B></I></FONT></P></TD>
    <TD vAlign=top width="33%"><B><I><FONT size=2>
      <P align=center>Notes</B></I></FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>1</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>/Strobe</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output (OC)</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>2</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Data_0</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>3</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Data_1</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>4</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Data_2</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>5</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Data_3</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>6</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Data_4</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>7</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Data_5</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>8</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Data_6</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>9</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Data_7</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>10</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>/ACK</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Input</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>11</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Busy</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Input</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>12</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Paper Empty</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Input</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>13</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Select</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Input</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>14</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>/Autofeed</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>15</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>/Error</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Input</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>16</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Init Printer</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>17</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>/Select_Input</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>PC Output</FONT></P></TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>18</FONT></P></TD>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>Ground</FONT></P></TD>
    <TD vAlign=top width="33%">&nbsp;</TD></TR>
  <TR>
    <TD vAlign=top width="33%"><FONT size=2>
      <P align=center>-25</FONT></P></TD>
    <TD vAlign=top width="33%">&nbsp;</TD>
    <TD vAlign=top width="33%">&nbsp;</TD></TR></TBODY></TABLE><I><FONT size=2>
<P>Table 1 - Parallel Port Terminal Designations</P></FONT>
<P>&nbsp;</P></I></I>
<P>&nbsp;</P><FONT face=times size=+1><PRE>
   Every parallel port has three port addresses: Data, Status, and
   Control. The three of them are in sequential order. (I.e., if the Data
   port is 0x378 then the Control port is 0x378+1, and so on).
      
   
   So, how do you find out what the port address of your parallel port
   it? That depends on your platform. If you are under DOS, you can do
   the following:
   
   
   
   C:\&gt;debug
   
   -d 0040:08 L8
   
   0040:0008 78 03 78 02 00 00 00 00
   
   
   
   The above is an example of an output from the debug command d 0040:08
   L8. The port address resides in the memory location 0040:08.
   
   
   
   Outputs:
   
   
   
   Note that there are eight output on the Data Port, and four additional
   outputs on the low nibble of the Control Port (/SELECT_IN, INIT,
   /AUTOFEED, and /STROBE).
   
   
   
   Luckily, all outputs to the Data Port are true logic. However, the
   /SELECT_IN, /AUTOFEED, and /STROBE outputs on the Control Port are
   inverted.
   
   
   
   Let's see some sample code:
   
   
/* codecodecodecodecodecodecodecodecodecodecodecodecodecodecodecodecode */   
   
   
   #include &lt;stdio.h&gt;
   #include &lt;unistd.h&gt; /* needed for ioperm() */
   #include &lt;asm/io.h&gt; /* for outb() and inb() */
   
   
   #define DATA 0x378
   #define STATUS DATA+1
   #define CONTROL DATA+2
   

   int main(void)
   {
   int x = 0x32;
   int y = 0x08;
   

   if (ioperm(DATA,3,1)) {
   	printf("Sorry, you were not able to gain access to the ports\n");
   	printf("You must be root to run this program\n");
   	exit(1);
   	}
   
   
   outb(DATA, x); /* Sends 0011 0010 to the Data Port */
   outb(CONTROL, y^0x0b);
   
   /* SELECT_IN = 1, INIT = 0, /AUTO_FEED = 0, /STROBE = 0 */
   
   return (0);
   
   
   }
   
/* codecodecodecodecodecodecodecodecodecodecodecodecodecodecodecodecode */
   
   
   The above code will work on a Linux. As far as SunOS is concerned there
   are two files you need to include (sys/ddi.h) and (sys/sunddi.h) for
   the inb() and outb() functions. 

   You also need to compile with -O or -O2 or similar. The reason for that
   is that inb() and family are defined as inline macros, and compiling
   them without optimization enabled will cause unresolved references at
   link time (Someone in #c came and kept on asking about it, and I thought
   I would add this part in). [If people would only read the man pages!].

   
   
   
   Inputs:
   
   
   
   There are five status leads for the Status Port. (BSY, /ACK, PE,
   SELECT, /ERROR). The reasons they are named like that is that it was
   originally designed for a printer only. So, we have things like PE
   (paper empty), etc.
   
   
   
   Beware, the BSY is inverted using hardware, so when receiving input
   from there, make sure you invert this bit so you can have what
   represents a true logic.
   
   
   
   
   
   This is how to read the five most significant bits in true logic:
   
   
   
   Value = ((inb(STATUS)^0x80) &gt;&gt; 3);
   
   
   
   Notice how we inverted the BSY bit using the exclusive-or function.
   Then, we shifted the bits 3 times to the right, resulting in the upper
   five bits ending up in the lower five bit positions.
   
   
   
   0 0 0 BUSY /ACK PE SELECT /ERROR
   
   
   
   
   
   In conclusion, we should have realized by now that there are 12
   outputs (eight on the data port, and four on the lower nibble of the
   control port). There are five inputs, on the highest five bits of the
   status port. Three output bits on the control por t and one input on
   the status port are inverted by the hardware.
   
   
   
   Problems and Solutions:
   
   
   
   It may have occurred to you that there are only five bits on the
   parallel port for input. This could be a real inconvenience when
   interfacing with 8-bit analog to digital converters. One solution to
   this problem is to add external circuitry to store the 8-bit result
   and gate in 4-bits at a time.
   
   
   
   So what can we do about it?
   
   
   
   What I did not mention about the Control Port (other than having four
   outputs) is that they are bi-directional. They can be outputs and
   inputs! Dont you just love how confusing they can get?
   
   
   
   Using the control port bi-directional bits is not as simple as just
   reading them using inb(). We have to force all the four outputs on the
   lower nibble of the control port to logic one. This will result in
   external signals being forced on these inputs and then we can read
   using the inb().
   
   
   
   int i;
   
   
   
   outb(CONTROL, 0x0f^0x0b);
   
   /* inverting to go around the hardware inversion */
   
   i = (inb(CONTROL) &amp; 0x0f) ^ 0x0b;
   
   
   
   
   
   Doing so, we would have solved our little problem there.
   
   
   Other Handy Macros

   Now, let's say you want to send a word to portX and portX+1 instead
   of just sending a byte to portX and then another byte to portX+1.
   outw(value,portX) will do the trick. inw(portX) will return a word
   from portX and portX+1.

   Now usually when sending data to the parallel port you need a slight
   delay to ensure that the data has been sent, and not lost. Instead of
   having extra calls, and more code, there is outb_p() inb_p() outw_p()
   and inw_p() which gives us a delay of about 1 microsecond. If that
   is not enough delay, you can always #define REALLY_SLOW_IO before
   the #include <ASM io.h>. Those macros use a port output to port 0x80
   for their delay. So you need to give access to that port with ioperm().


   Final Words On Permissions

   In order to use ioperm() you will need to have root privileges. If you
   don't want that, then you can always use setuid.

   
   Programming the parallel port can be a lot fun. The only thing that
   can actually be a pain in it is all this inverting you have to do
   every now and then. For most simple projects, you only need to use the
   8-bits in your data port (ie, the base port).
   
   
   
   Finally, I must warn you that if you intend to do anything with your
   parallel port, make sure it is not integrated with your motherboard.
   Chances are, if you blow something up, it's going to be your
   motherboard. What you should so is buy a 386, or any old machine you
   can mess around with. I say 386 because it's the first of the 32-bit
   processors for the IBM PC (so I can actually run Linux on it). It's a
   free world, use whatever your heart desires, just don't test it on
   your PII!

</PRE>
<HR>
<I><FONT color=#008080 size=-1>This page is Copyright © 1997 By <A 
href="http://cscene.oftheinter.net/">C Scene</A>. All Rights Reserved 
</FONT></I>
<HR>
</FONT></BODY></HTML>
