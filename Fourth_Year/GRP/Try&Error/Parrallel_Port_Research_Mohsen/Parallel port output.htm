<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0054)http://www.epanorama.net/circuits/parallel_output.html -->
<HTML><HEAD><TITLE>Parallel port output</TITLE>
<META 
content="Simple circuits and examples to describe how to use PC parallel port as general purpose output port." 
name=description>
<META 
content=PC,parallel,LPT,port,controlling,programming,circuit,circuits,example,output,relay,LED,controlling 
name=keywords>
<META content=global name=distribution>
<META content="1996-2006 Tomi Engdahl" name=copyright>
<META name=author contents="Tomi Engdahl">
<META content="MSHTML 6.00.2900.2180" name=GENERATOR>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1"><LINK 
href="Parallel port output_files/style.css" type=text/css rel=stylesheet><LINK 
media=print href="Parallel port output_files/print.css" type=text/css 
rel=stylesheet>
<SCRIPT src="Parallel port output_files/urchin.js" 
type=text/javascript>
</SCRIPT>

<SCRIPT type=text/javascript>
_uacct = "UA-272685-1";
urchinTracker();
</SCRIPT>

<SCRIPT type=text/javascript>
<!--
function changeImages(elem, changeimg) {
	if(document.images){
		document.images[elem].src = eval(changeimg + ".src");
	}
}

if (document.images) {
	var links_btn  = new Image();
	links_btn.src = "/images/links-btn.jpg";
	var links_btn_over  = new Image();
	links_btn_over.src = "/images/links-btn-over.jpg";
	var circuits_btn = new Image();
	circuits_btn.src = "/images/circuits-btn.jpg";
	var circuits_btn_over = new Image();
	circuits_btn_over.src = "/images/circuits-btn-over.jpg";
	var documents_btn = new Image();
	documents_btn.src = "/images/documents-btn.jpg";
	var documents_btn_over = new Image();
	documents_btn_over.src = "/images/documents-btn-over.jpg";
	var forum_btn = new Image();
	forum_btn.src = "/images/forum-btn.jpg";
	var forum_btn_over = new Image();
	forum_btn_over.src = "/images/forum-btn-over.jpg";
	var software_btn = new Image();
	software_btn.src = "/images/software-btn.jpg";
	var software_btn_over = new Image();
	software_btn_over.src = "/images/software-btn-over.jpg";
	var rfc_btn = new Image();
	rfc_btn.src = "/images/rfc-btn.jpg";
	var rfc_btn_over = new Image();
	rfc_btn_over.src = "/images/rfc-btn-over.jpg";
	var search_btn = new Image();
	search_btn.src = "/images/search-btn.jpg";
	var search_btn_over = new Image();
	search_btn_over.src = "/images/search-btn-over.jpg"; 
	var toolbox_btn = new Image();
	toolbox_btn.src = "/images/toolbox-btn.jpg";
	var toolbox_btn_over = new Image();
	toolbox_btn_over.src = "/images/toolbox-btn-over.jpg";
}
// -->
</SCRIPT>
<!-- ValueClick Media POP-UNDER CODE v1.8 for epanorama.net (12 hour) -->
<SCRIPT language=javascript><!--
var dc=document; var date_ob=new Date();
dc.cookie='h2=o; path=/;';var bust=date_ob.getSeconds();
if(dc.cookie.indexOf ('e=llo') <= 0 && dc.cookie.indexOf('2=o') > 0){
dc.write('<scr'+'ipt language="javascript" src="http://media.fastclick.net' );
dc.write('/w/pop.cgi?sid=6044&m=2&tp=2&v=1.8&c='+bust+'"></scr'+'ipt>');
date_ob.setTime(date_ob.getTime()+43200000);
dc.cookie='he=llo; path=/; expires='+ date_ob.toGMTString();} // -->
</SCRIPT>
<!-- ValueClick Media POP-UNDER CODE v1.8 for epanorama.net --><!-- FASTCLICK.COM INTERSTITIAL HEAD CODE v1.0 for epanorama.net -->
<SCRIPT language=javascript><!--
function FCx(x){
  var min=15; // minimum minutes between interstitials (needs to be >15)
  if(x.indexOf('get.media')>0){
    x=unescape(x.substring(x.indexOf('&url=')+5,x.length));
  }else{
    if(document.cookie.indexOf('CxIC=1')<=0){
      x='http://media.fastclick.net/w/get.media?sid=6044&m=5&url='+escape(x);
      var date_ob=new Date();
      date_ob.setTime(date_ob.getTime()+min*1000*60);
      document.cookie='FCxIC=1; path=/; expires='+date_ob.toGMTString();
    }
  }
  return x
}
// -->
</SCRIPT>
<!-- FASTCLICK.COM INTERSTITIAL HEAD CODE v1.0 for epanorama.net --></HEAD>
<BODY>
<DIV class="fullpage region1" id=wrapper>
<DIV class=googlebanner>
<SCRIPT type=text/javascript><!--
google_ad_client = "pub-3257650267345122";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel ="5495687474";
google_color_border = "336699";
//--></SCRIPT>

<SCRIPT src="Parallel port output_files/show_ads.js" 
type=text/javascript>
</SCRIPT>
</DIV>
<DIV class=coname><A href="http://www.epanorama.net/index.php"><IMG 
src="Parallel port output_files/logo.jpg" border=0 name=logo></A></DIV>
<DIV class=hline>
<HR>
</DIV>
<DIV class=navbtns id=navbuttons><A 
onmouseover="changeImages('links_btn', 'links_btn_over')" 
onmouseout="changeImages('links_btn', 'links_btn')" 
href="http://www.epanorama.net/index.php?index=link"><IMG class=imgplain 
id=links_btn title=Links alt=Links 
src="Parallel port output_files/links-btn.jpg"></A> <A 
onmouseover="changeImages('circuits_btn', 'circuits_btn_over')" 
onmouseout="changeImages('circuits_btn', 'circuits_btn')" 
href="http://www.epanorama.net/index.php?index=circuit"><IMG class=imgplain 
id=circuits_btn title=Circuits alt=Circuits 
src="Parallel port output_files/circuits-btn.jpg"></A> <A 
onmouseover="changeImages('documents_btn', 'documents_btn_over')" 
onmouseout="changeImages('documents_btn', 'documents_btn')" 
href="http://www.epanorama.net/index.php?index=document"><IMG class=imgplain 
id=documents_btn title=Documents alt=Documents 
src="Parallel port output_files/documents-btn.jpg"></A> <A 
onmouseover="changeImages('forum_btn', 'forum_btn_over')" 
onmouseout="changeImages('forum_btn', 'forum_btn')" 
href="http://www.epanorama.net/index.php?index=discussion"><IMG class=imgplain 
id=forum_btn title=Forum alt=Forum 
src="Parallel port output_files/forum-btn.jpg"></A> <A 
onmouseover="changeImages('software_btn', 'software_btn_over')" 
onmouseout="changeImages('software_btn', 'software_btn')" 
href="http://www.epanorama.net/software-list.php"><IMG class=imgplain 
id=software_btn title=Software alt=Software 
src="Parallel port output_files/software-btn.jpg"></A> <A 
onmouseover="changeImages('rfc_btn', 'rfc_btn_over')" 
onmouseout="changeImages('rfc_btn', 'rfc_btn')" 
href="http://www.epanorama.net/RFC/rfc_index.html"><IMG class=imgplain 
id=rfc_btn title=RFC alt=RFC src="Parallel port output_files/rfc-btn.jpg"></A> 
<A onmouseover="changeImages('toolbox_btn', 'toolbox_btn_over');" 
onmouseout="changeImages('toolbox_btn', 'toolbox_btn');" 
href="http://www.epanorama.net/index.php?index=calculator"><IMG class=imgplain 
id=toolbox_btn title=ToolBox alt=ToolBox 
src="Parallel port output_files/toolbox-btn.jpg"></A> <A 
onmouseover="changeImages('search_btn', 'search_btn_over')" 
onmouseout="changeImages('search_btn', 'search_btn')" 
href="http://www.epanorama.net/multi.php"><IMG class=imgplain id=search_btn 
title=Search alt=Search src="Parallel port output_files/search-btn.jpg"></A> 
</DIV>
<DIV class=navtext id=nav2>| <A class=btext 
href="http://www.epanorama.net/index.php">Index</A> | <A class=btext 
href="http://www.epanorama.net/schematicsforfree/index.php">Schematics</A> | <A 
class=btext href="http://www.epanorama.net/acronym.html">Acronyms</A> | <A 
class=btext 
href="http://www.epanorama.net/wwwboard/wwwboard.html">Discussion</A> | <A 
class=btext href="http://www.epanorama.net/m2f/friendmail.php">Mail to a 
friend</A> | <A class=btext href="http://www.epanorama.net/pagediscuss.php">Post 
a message</A> | </DIV>
<DIV class=searcht id=searchtop>
<FORM name=searchfrm action=http://new.epanorama.net/multi.php 
method=get><SELECT class=btext name=search> <OPTION value="" selected>Search 
  this site</OPTION> <OPTION value=search>Site pages/links</OPTION> <OPTION 
  value=companysearch>Company</OPTION> <OPTION value=acro>Acronym info</OPTION> 
  <OPTION value=semi>Semiconductor info</OPTION> <OPTION 
  value=wwwboardsearch>Discussion messages</OPTION> <OPTION 
  value=circuitsitesearch>Circuit sites</OPTION> <OPTION value=otherlink>Other 
  search engines</OPTION></SELECT> <INPUT name=keyword> <A 
href="http://www.epanorama.net/circuits/parallel_output.html#"><IMG 
onclick="javascript: document.searchfrm.submit();" height=21 alt="" 
src="Parallel port output_files/search.gif" width=52 align=absBottom 
border=0></A> </FORM></DIV>
<DIV class=midPage id=mainContent>
<H1>Parallel port interfacing made easy: Simple circuits and programs to show 
how to use PC parallel port output capabilities</H1>
<P><I>Copyright Tomi Engdahl 1996-2006</I> 
<P>
<H2>Index</H2>
<UL>
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#intro">Introduction</A> 

  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#circuithow">How 
  to connect circuits to parallel port</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#doscontrol">Control 
  program for DOS (and Win9x)</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#dosprogramming">Parallelport 
  programming in DOS</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#windowsprogramming">Parallel 
  port controlling in Windows programs</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#linuxprogramming">Parallel 
  port controlling in Linux</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#webcontrol">Controlling 
  parallel port through web</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#realworld">Controlling 
  some real world electronics</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#relaycontrol">Building 
  your own relay controlling circuits</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#mainspower">Mains 
  power controlling with parallel port</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#multiout">Compact 
  8 channel output driver</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#circuitlinks">Links 
  to parallel port output circuits</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#controlsoftware">Ready 
  made control software</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#input">Reading 
  the input pins in parallel port input pins</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#registers">Parallel 
  port software registers technical summary</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#bootupnotes">Notes 
  on parallel port operation during computer boot-up</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#portversions">Notes 
  on different parallel port versions</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#pcibus">Notes on 
  PCI bus parallel port cards</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#usbnotes">Notes 
  on USB parallel port adapters</A> 
  <LI><A 
  href="http://www.epanorama.net/circuits/parallel_output.html#documentlinks">Other 
  documents worth to check</A> </LI></UL>
<P>
<H2><A name=intro>Introduction</A></H2>
<P>PC parallel port can be very useful I/O channel for connecting your own 
circuits to PC. The PC's parallel port can be used to perform some very amusing 
hardware interfacing experiments. The port is very easy to use when you first 
understand some basic tricks. This document tries to show those tricks in easy 
to understand way. 
<P><B>WARNING: PC parallel port can be damaged quite easily if you make mistakes 
in the circuits you connect to it. If the parallel port is integrated to the 
motherboard (like in many new computers) repairing damaged parallel port may be 
expensive (in many cases it it is cheaper to replace the whole motherborard than 
repair that port).</B> Safest bet is to buy an inexpensive I/O card which has an 
extra parallel port and use it for your experiment. If you manage to damage the 
parallel port on that card, replacing it is easy and inexpensive. 
<P>NOTE: The I/O port level controlling details here has proven to work well 
with parallel ports on the PC motherboard and expansion cards connected to ISA 
bus. The programming examples might not work with PCI bus based I/O cards (they 
can use different hardware and/or I/O addresses, their drivers make they just 
look like parallel ports to "normal" applications). The programming examples do 
not work with USB to parallel port adapters (they use entirely different 
hardware, their drivers make them to look like normal parallel port to operating 
system "normal" applications). 
<P><B>DISCLAIMER: Every reasonable care has been taken in producing this 
information. However, the author can accept no responsibility for any effect 
that this information has on your equipment or any results of the use of this 
information. It is the responsibly of the end user to determine fitness for use 
for any particular purpose. The circuits and software shown here are for non 
commercial use without consent from the author. </B>
<P>
<H2><A name=circuithow>How to connect circuits to parallel port</A></H2>
<P>PC parallel port is 25 pin D-shaped female connector in the back of the 
computer. It is normally used for connecting computer to printer, but many other 
types of hardware for that port is available today. 
<P>Not all 25 are needed always. Usually you can easily do with only 8 output 
pins (data lines) and signal ground. I have presented those pins in the table 
below. Those output pins are adequate for many purposes. 
<P><PRE>pin function
 2   D0
 3   D1
 4   D2
 5   D3
 6   D4
 7   D5
 8   D6
 9   D7
</PRE>Pins 18,19,20,21,22,23,24 and 25 are all ground pins. 
<P>Those datapins are TTL level output pins. This means that they put out 
ideally 0V when they are in low logic level (0) and +5V when they are in high 
logic level (1). In real world the voltages can be something different from 
ideal when the circuit is loaded. The output current capacity of the parallel 
port is limited to only few milliamperes. 
<P>Here is a simple idea how you can connect load to a PC parallel port data 
pins. 
<P><PRE>        Dn Out ------+
                     |+
  Sourcing         Load (up to 2.6 mA @ 2.4 v)
                     |-
        Ground ------+
</PRE>
<P>This is not the only way to connect things to a parallel port. 
<P>The parallel port data pins are TTL outputs, that can both sink and source 
current. In ordinary parallel port implementations the data outputs are 74LS374 
IC totem-pole TTL outputs which can source 2.6 mA and sink 24 mA. 
<P>Regular TTL outputs basically consist of a two "stacked" transistor in series 
between +5 volts and ground, with the output coming from the connection between 
them. This is called a "totem pole output". At any given time one of these 
transistors is conducting and the other is not. To pull the output "high", the 
transistor from +5 to the output conducts (H), which "sources" positive current 
from the output to ground (that is, an external device between the output and 
ground will get power). To pull the output low, only the lower transistor (L) 
conducts, "sinking" current to ground; an external device between +5 volts and 
the output can be energized. 
<P><PRE>         +5      
        /    |
    ---H on  V      
        \      --&gt;   
         |________        TTL output on = 1 = high, "sourcing" current
         |   out  \
        /         / |
    ---L off      \ V
        \_________/
        Gnd      


       +5_________
        /         \
    ---H off      / |
        \         \ V
         |________/      TTL output off = 0 = low, "sinking" current
         |  &lt;-- out
        /
    ---L on |
        \   V
        Gnd      
</PRE>
<P>The outputs are designed so that they give at least 2.4V at 2.6 mA load. This 
2.6 mA figure is for ordinary LS-TLL circuits used, the LSI implementations used 
in many computers can give more or less. For example quite popular (few years 
ago) UM82C11-C parallel port chip can only source 2 mA. 
<P>Simple current sinking load connection: 
<P><PRE>        Dn Out ------+
                     |+
  Sourcing         Load (up to 2.6 mA @ 2.4 v)
                     |-
        Ground ------+
</PRE>
<P>When taking current from PC parallel port, keep the load low, only up to few 
milliamperes. Trying to toke too much current (for example shorting pins to 
ground) can fry the parallel port. I have not killed any parallel port (yet) in 
this method, but I have had in cases where too much load has made the parallel 
port IC very hot. Be careful. 
<P>If you have an external +5 volt supply, you have another option for 
connection: use the Data Out pins to sink up to 24 mA from your +5 volt supply. 
This can be made with a circuit like this: 
<P><PRE>                     +------------------------------- (+5 v)
                     |+
   Sinking         Load (up to 24 mA @ 4.2v)
                     |-	     Power Supply
        Dn Out ------+

        Ground -------------------------------------- ( Gnd)
</PRE>
<P>The load gets power then you have external +5V on and the printer port data 
pin set to 0. This circuit gives you capability of of driving more current than 
the "sinking" approach. You need to be careful with this circuit, because with 
this circuit you can easily fry the parallel port if you do things wrong. My 
advice is to be very careful with this type of circuit and make sure that the 
external +5V power supply gets turned off when computer gets turned off (all 
printer ports might not like getting +5V though the load to printer port when 
they are not powere). The most convient source "external +5V" might be from same 
other port on your PC (USB, joystick, keyboard/mouse etc. port). 
<P>I have used mostly "sinking" type circuits and this article is concentrated 
on using them. 
<P>
<H3>Simple LED driving circuits</H3>
<P>You can make simple circuit for driving a small led through PC parallel port. 
The only components needed are one LED and one 470 ohm resistors. You simply 
connect the diode and resistor in series. The resistors is needed to limit the 
current taken from parallel port to a value which light up acceptably normal 
LEDs and is still safe value (not overloading the parallel port chip). In 
practical case the output current will be few milliampres for the LED, which 
will cause a typical LED to somewhat light up visibly, but not get the full 
brigtness. 
<P><IMG alt="LED and resistor" src="Parallel port output_files/led_r.gif"> 
<P>Then you connect the circuit to the parallel port so that one end of the 
circuit goes to one data pin (that one you with to use for controlling that LED) 
and another one goes to any of the ground pins. Be sure to fit the circuit so 
that the LED positive lead (the longer one) goes to the datapin. If you put the 
led in the wrong way, it will not light in any condition. You can connect one 
circuit to each of the parallel port data pins. In this way you get eight 
software controllable LEDs. 
<P><IMG alt="LEDs wired to parallel port" 
src="Parallel port output_files/lptleds.gif"> 
<P>
<P>The software controlling is easy. When you send out 1 to the datapin where 
the LED is connected, that LED will light. When you send 0 to that same pin, the 
LED will no longer light. 
<P>Here are two photos of circuit above I have built: 
<P><IMG alt="LEDs wired to parallel port circuit photo 1" 
src="Parallel port output_files/lptcircuit1.jpg"> <BR><IMG 
alt="LEDs wired to parallel port circuit photo 2" 
src="Parallel port output_files/lptcircuit2.jpg"> 
<P>Pn those circuits I have wired the ground wire only to one ground pin (it 
works also well, you can use any of the ground pins). 
<P>
<H3>Technical specifications of parallel port pins</H3>
<P>The IBM specifications says accoding <A 
href="http://www.epanorama.net/counter.php?url=http://www.linux.com/howtos/IO-Port-Programming-6.shtml">http://www.epanorama.net/counter.php?url=http://www.linux.com/howtos/IO-Port-Programming-6.shtml</A> 
the following: The data output pins (pins 2-9) sink 24 mA, source 15 mA, and 
their high-level output is min. 2.4 V. The low state for both is max. 0.5 V. 
Pins 1, 14, 16, and 17 (the control outputs) have open collector drivers pulled 
to 5 V through 4.7 kiloohm resistors (sink 20 mA, source 0.55 mA, high-level 
output 5.0 V minus pullup). Non-IBM parallel ports probably deviate from this 
standard. 
<P>Warning: Be careful with grounding. You can break parallel ports by 
connecting devices to them when PC is powered on. It is not a good idea to short 
the pins to ground or +5V, this can damage the port. It might be a good thing to 
use a parallel port not integrated on the motherboard for things like this. (You 
can usually get a second parallel port for your machine with a cheap standard 
`multi-I/O' card) 
<P>
<H2><A name=doscontrol>Control program for DOS (and Win9x)</A></H2>
<P>The following program is an example how to control parallel port LPT1 data 
pins from your software. This example directly controls the parallel port 
registers, so it does not work under some multitasking operating system which 
does not allow that. It works nicely under MSDOS. You can look the Borland 
Pascal 7.0 code (should compile also with earlier versions also) and then 
download the compiled program <A 
href="http://www.epanorama.net/circuits/lptout.exe">LPTOUT.EXE</A>. This has 
worked nicely for me in DOS systems and Windows 95/98 systems. On recent 
testings this program has worked unreliably on some Windoes 2000 systems. 
<P><PRE>Program lpt1_output;

Uses Dos;

Var
   addr:word;
   data:byte;
   e:integer;

Begin
   addr:=MemW[$0040:$0008];
   Val(ParamStr(1),data,e);
   Port[addr]:=data;
End.
</PRE>
<H3>How to use the program</H3>
<P>LPTOUT.EXE is very easy to use program. The program takes one parameter, 
which is the data value to send to the parallel port. That value must be integer 
in decimal format (for example 255). Hexadecimal numbers can also be used, but 
they must be preceded by $ mark (for example $FF). The program hoes not have any 
type of error checking to keep it simple. If your number is not in correct 
format, the program will send some strange value to the port. 
<P>NOTE: I have found out that this program does not work reliably on some 
Windows 2000 systems I have tested on this. I don't know what is causing this 
specific problem (other than you should not try to access hardware directly on 
Windows NT based system..). I have not tested this program with Windows XP. 
<P>
<H3>Example how to use the program</H3>
<P>LPTOUT 0<BR>Set all datapins to low level.<BR><BR>LPTOUT 255<BR>Set all 
datapins to high level.<BR><BR>LPTOUT 1<BR>Set datapin D0 to high level and all 
other datapins to low level.<BR><BR>
<H4>How to calculate your own values to send to program</H4>
<P>You have to think the value you give to the program as a binary number. Every 
bit of the binary number control one output bit. The following table describes 
the relation of the bits, parallel port output pins and the value of those bits. 
<PRE>Pin     2   3   4   5   6   7   8   9
Bit     D0  D1  D2  D3  D4  D5  D6  D7
Value   1   2   4   8   16  32  64  128
</PRE>For example if you want to set pins 2 and 3 to logic 1 (led on) then you 
have to output value 1+2=3. If you want to set on pins 3,5 and 6 then you need 
to output value 2+8+16=26. In this way you can calculate the value for any bit 
combination you want to output. 
<P>
<H3>Making changes to source code</H3>
<P>You can easily change te parallel port number int the source code by just 
changing the memory address where the program read the parallel port address. 
For more information, check the following table. 
<P><PRE>Format of BIOS Data Segment at segment 40h:
Offset  Size    Description
 08h    WORD    Base I/O address of 1st parallel I/O port, zero if none
 0Ah    WORD    Base I/O address of 2nd parallel I/O port, zero if none
 0Ch    WORD    Base I/O address of 3rd parallel I/O port, zero if none
 0Eh    WORD    [non-PS] Base I/O address of 4th parallel I/O port, zero if none
</PRE>For example change the line <B>addr:=MemW[$0040:$0008];</B> in the source 
code to <B>addr:=MemW[$0040:$000A];</B> if you want to output to LPT2. 
<P>Instead of trying to read the address from the DOS information data block you 
can always use the I/O address fixed to source code. The LPT1 port is typically 
at I/O-address 378h or 3BCh. 
<P>To get to know the port address to use you can use for example the method: On 
modern Windows systems (I tested in Windows 2000) you can get to know the 
parallel port I/O addrss through device manager. First open the device manager 
(start - settings - control panel - system - hardware - device manager). Then 
select there the parallel port you are interrested from Ports (COM &amp; LPT) 
section. With mouse right button you can get menu where you select Properties. 
From there select Resources where you should see a screen like this: 
<P><IMG alt="Windows device control IO address view" 
src="Parallel port output_files/io_properties.gif"> 
<P>The details in this image are from the parallel port built into the 
motherboard of my PC. 
<P>
<H2><A name=dosprogramming>Parallelport programming in DOS</A></H2>
<P>The following examples are short code examples how to write to I/O ports 
using different languages. In the examples I have used I/O address 378h which is 
one of the addresses where parallel port can be. 
<P>The typical parallel port I/O addess configurations seen on PCs with ISA bus: 

<UL>
  <LI>LPT1: 3BCh, LPT2: 378h, LPT3: 278h 
  <LI>LPT1: 378h, LPT2: 278h 
  <LI>LPT1: 378h </LI></UL>Those are the typical I/O addresses used in ISA bus 
based systems. In PCI bus based systems the LPT1 port on motherboard is 
typically at I/O-address 378h or 3BCh. If the systems has extra LPT ports on 
multi-IO card in PCI bus, those extra LPT ports work differently than the 
"normal parallel port" described in this document, and the same control methods 
can't be applied to them (they are on different I/O addresses and could use 
different control register system that could be card specific, the driver 
software that comes with the card makes them to look like LPT ports for the 
applications using standard operating system printing routines). 
<P>The following examples are for DOS system (they might or might not work on 
other systems). The code examples are designed to be used with LPT1 port that 
resides in I/O address 378h. 
<P>
<H3>Assembler</H3><PRE>MOV DX,0378H
MOV AL,n
OUT DX,AL 
</PRE>Where n is the data you want to output. 
<P>
<H3>BASIC</H3><PRE>OUT &amp;H378, N
</PRE>Where N is the number you want to output. 
<P>
<H3>C</H3><PRE> 
outp(0x378,n);
</PRE>or <PRE>outportb(0x378,n);
</PRE>Where N is the data you want to output. The actual I/O port controlling 
command varies from compiler to compiler because it is not part of standardized 
C libraries. 
<P>Here is an example source code for Borland C++ 3.1 compiler: <PRE>#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;
#include &lt;conio.h&gt;

/********************************************/
/*This program set the parallel port outputs*/
/********************************************/

void main (void)
{
clrscr();             /* clear screen */
outportb(0x378,0xff); /* output the data to parallel port */
getch();              /* wait for keypress before exiting */
}
</PRE>
<P>
<H3>Using DOS debug to access parallel port</H3>
<P>DOS program Debug is a simple 8088 assembler that comes with DOS operating 
system (comes with DOS utilities on most modern WIndows systems as well). Debug 
allows debugging of simple 16-bit DOS applications (not useful to modern 32-bit 
Windows programs). Debug program has several built-in debugging tool commands, 
including commands to read and write I/O ports. <PRE>o- writes one byte of dat to the specified I/O port
SYNTAX o port value
port - specifies the port address. The port address can be an 8 or a 16 bit value.
value - specified the value to write to this I/O-port. This value is 8 bit value.

i- reads one byte of data from the specified I/O port
SYNTAX i port
port - specifies the port address. The port address can be an 8 or a 16 bit value.
</PRE>
<P>Examples: <PRE>If you type 

o 3bc ff

debug will output value ff (hex) to port 3bc (hex).

If you type
 
i 3bc
 
debug will display 1 byte of data from the parallel port.
</PRE>
<P>
<H2><A name=windowsprogramming>Parallel port controlling in Windows 
programs</A></H2>
<P>Writing programs to talk with parallel port was pretty easy in old DOS days 
and in Win95/98 too. We can use Inporb and outportb or _inp() or _Outp functions 
in our program without any problem if we are running the program on Dos or 
WIN95/98. But entering to the new era of NT clone operating systems like WIN 
NT4, WIN2000, WINXP, all this simplicity goes away. 
<P>Direct parallel port controlling in possible under Windows 3.x and Windows 95 
directly from 16 bit application programs and DLL libraries. So you can use the 
C example above in Windows 3.x and Windows 95 if you make your program 16 bit 
application. If you want to control parallel port from Visual Basic or Delphi 
then take a look at the libraries at <A 
href="http://www.epanorama.net/counter.php?url=http://www.lvr.com/parport.htm">Parallel 
Port Central</A> at <A 
href="http://www.epanorama.net/counter.php?url=http://www.lvr.com/parport.htm">http://www.epanorama.net/counter.php?url=http://www.lvr.com/parport.htm</A>. 

<P>Direct port controlling from application is not possible under Windows NT and 
to be ale to control the parallel port directly you will need to write some kind 
of device driver to do this. You can find also this kind of drivers from <A 
href="http://www.epanorama.net/counter.php?url=http://www.lvr.com/parport.htm#Programming">Parallel 
Port Central</A> and <A 
href="http://www.epanorama.net/counter.php?url=http://www.logix4u.net/inpout32.htm">Inpout32.dll 
for WIN NT/2000/XP</A>. 
<P><A 
href="http://www.epanorama.net/counter.php?url=http://www.driverlinx.com/DownLoad/DlPortIO.htm">Driverlinx 
PortIO</A> at <A 
href="http://www.epanorama.net/counter.php?url=http://www.driverlinx.com/DownLoad/DlPortIO.htm">http://www.epanorama.net/counter.php?url=http://www.driverlinx.com/DownLoad/DlPortIO.htm</A> 
is a worth to check driver for accessing I/O ports directly under Windows 95/NT 
(works also well with Windows 2000). This free software comes with example 
programs (both executable and source code available) how to access I/O ports 
from Visual Basic and Microsoft Visual C programs. 
<P>The I/O Control Using Using Visual Basic web page at <A 
href="http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/vb/vbout.htm">http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/vb/vbout.htm</A> 
describes how to make a simple Visual Basic application that controls PC 
parallel port. 
<P>If you are looking for a ready made software, then take a look at Kemo M125 
kit web page at <A 
href="http://www.epanorama.net/counter.php?url=http://www.kemo-electronic.com/en/module/m125/">http://www.epanorama.net/counter.php?url=http://www.kemo-electronic.com/en/module/m125/</A>. 
Kemo relay module M125 is designed for switching up to 8 different appliances, 
lamps or motors according to a computer program (up to 40V and loads up to 0,4A 
DC or 0,2A AC). The module is operated at the printer port LPT1 in the same way 
as my parallel port controlling circuit examples (in this module there is one 
solid state relay connected for each of those 8 data output pin on parallel 
port). Kemo M125 kit information page has control software available for 
download. Those software allows controlling of outputs manually and timed 
operation. Windows software runs in WIN9x, WIN2K and WINXP. There is also 
programming C source code example available. 
<P>Parallel port relay relay board kit described at <A 
href="http://www.epanorama.net/counter.php?url=http://electronickits.com/kit/complete/elec/ck1601.htm">http://www.epanorama.net/counter.php?url=http://electronickits.com/kit/complete/elec/ck1601.htm</A> 
comes with Windows and DOS control software that can be downloaded at the kit 
page. This software runs at Windows 9x/2000/ME/XP. Information on DOS utilities 
can be found at <A 
href="http://www.epanorama.net/counter.php?url=http://www.qkits.com/serv/qkits/diy/pages/QK74.asp">http://www.epanorama.net/counter.php?url=http://www.qkits.com/serv/qkits/diy/pages/QK74.asp</A>. 

<P>Parallel port monitors page at <A 
href="http://www.epanorama.net/counter.php?url=http://neil.fraser.name/software/lpt/">http://www.epanorama.net/counter.php?url=http://neil.fraser.name/software/lpt/</A> 
has programs that allow you to set and monitor parallel port pin states. The 
software is available for few different versions that work on Windows 98 / ME / 
NT / 2000 / XP and DOS / Windows 3.1 / 95 / 98 / ME systems. The software is 
written using Visual Basic and Euphoria programming languages and comes with 
source code. 
<P><A 
href="http://www.epanorama.net/counter.php?url=http://www.beyond-designs.com/PC_ports.htm">Beyond 
Design PC Serial and Parallel Port Software and Interfaces software 
VBPortTest</A> at <A 
href="http://www.epanorama.net/counter.php?url=http://www.beyond-designs.com/PC_ports.htm">http://www.epanorama.net/counter.php?url=http://www.beyond-designs.com/PC_ports.htm</A> 
is an useful utility. VBPortTest parallel port utility is designed to help test 
and debug parallel port interfaces. Allows access to the three registers (data, 
status, and control) associated with the PC standard parallel port (SPP). The 
user can read and write the data and control registers. The program continually 
reads the status register (the status register is read-only) . Individual 
register bits are displayed on LEDs along with the hex value for the entire data 
register. In write mode, the user can toggle individual bits by clicking on the 
corresponding LED. Hex values can be entered on the keyboard. Bit, byte and 
strobed byte write modes are possible. Online Help with useful parallel port 
reference material includes signal descriptions and Centronics handshake timing 
waveform. VBPortTest is available for download as freeware. Windows 98, ME, and 
XP compatible. 
<P>
<H3>Standard Windows API interface</H3>
<P>Standard Windows API for parallel port programming is targeted for sending 
out characters to printer onneced to parallel port. It is not designed for 
contrlling single pins on or off. 
<P>Using the parallel port for digital output can be made to work with the 
normal Windows API with a simple hardware hack. The main trick is to tie pins 
11(Busy) and 12 (Paper Error) to ground. Otherwise, the hardware driver will 
think the printer it is talking to is busy or experiencing an error and will not 
output any data. 
<P>Just send one character to parallel port, and the Windows wii send the value 
of that character to printer port data pins, plus generate one pulse to strobe 
line. The port will maintain the last value written to it until another value is 
written or until the computer is powered down or new data is sent to port. If 
you output more than one byte at a time the driver will send them to the port in 
sequence and toggle the Strobe line (line 1) off and on for each byte. The 
timing involved varies somewhat from one computer to the next. 
<P>This means that in a Windows environment we can output data to the parallel 
port. You can send data even through Windows command line with copy command like 
this: <PRE>copy somefile.bin LPT1
</PRE>
<P>This will send the contents of file somefile.bin to the parallel port. The 
value of the last byte in the file will be left as the state of the parallel 
port after the command execution. 
<P>Besides need for the hardware hack, there are other limitations on the 
Windows API method. Windows API does not have built in support for input 
operations nor reading back the last sent value. Even though the parallel port 
hardware supports it, the software driver does not. 
<P>
<H2><A name=#linuxprogramming>Parallel port controlling in Linux</A></H2>
<P>Linux will allow acess to any port using the ioperm syscall. Here is some 
code parts for Linux to write 255 to printer port: <PRE>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;asm/io.h&gt;

#define base 0x378           /* printer port base address */
#define value 255            /* numeric value to send to printer port */

main(int argc, char **argv)
{
   if (ioperm(base,1,1))
    fprintf(stderr, "Couldn't get the port at %x\n", base), exit(1);

   outb(value, base);
}
</PRE>Save the source code to file lpt_test.c and compile it with command: <PRE>gcc -O lpt_test.c -o lpt_test
</PRE>
<P>The user has to have the previledges to have access to the ports for the 
program to run, so you have to be root to be able to ron this kind of programs 
without access problems. If you want to make a program which can be run by 
anybody then you have to first set the owner of the program to be root (for 
example do compilation when yhou are root), give the users rights to execute the 
program and then set the program to be always executed with owner (root) rights 
instead of the right of the user who runs it. You can set the programn to be run 
on owner rights by using following command: <PRE>chmod +s lpt_test
</PRE>
<P>Notes on source code: Some people have reported that for some reason this 
code does not work on theuir systems. If you have problems in getting this to 
work, try tho following chagest to code: replace the lines "#include 
&lt;unistd.h%gt;" and "#include &lt;asm/io.h&gt;" with line "#include 
&lt;sys/io.h&gt;" and then replace line "#define base 0x378" with "#define base 
0x0378". 
<P>If you want a more useful program, then download my <A 
href="http://www.epanorama.net/circuits/lptout.c">lptout.c parallel port 
controlling program source code</A>. That program works so that you can give the 
data to send to parallel port as the command line argument (both decimal and 
hexadecimal numbers supported) to that program and it will then output that 
value to parallel port. You can compile the source code to <B>lptout</B> command 
using the following line to do the compilation: <PRE>gcc -O lptout.c -o lptout
</PRE>
<P>After you have compiled the program you can run it easily. For example 
running <B>./lptout 0xFF</B> will turn all data pins to 1 and running 
<B>./lptout 0x00</B> will turn all data pins to 0. 
<P>In some systems the I/O port addresses can be different than one used in my 
example program. In this case you need to modify the address in #define base 
line. There are different ways to know the port address. First you could try 
your graphical configuration tools to look for this information. Those tools and 
how to use them vary quite much between different Linux distributions. There are 
also some command line tools you can try: 
<UL>
  <LI>In many linux systems you can get information on I/O devices and ports 
  they use with command "cat /proc/ioports". This list should include your 
  parallel port or parallel ports in it. The first parallel port (port in 
  motherboard) typically has name parport0. There are some cases where you might 
  not see your device in your list or sometimes you see the sama name twice 
  (usually the first one is the right one). 
  <LI>In some systems you might have additional parallel ports on I/O cards in 
  the PCI bus. In many new Linux systems you can run "lspci -v | more" to get 
  information of each device on your PCI bus (this should tell make and model, 
  interrupt and port and memory block assignments). </LI></UL>
<P>I have also written a more feature rich program to control. portconrol is a 
simple general purpose I/O port control program for Linux. It allows you to 
write and read the supported I/O ports. The software allows writing specified 
value to port, reading value at given I/O address and printing it out to screen 
in different formats and bit-level manipulation of the port data. The 
portcontrol software is available as <A 
href="http://www.epanorama.net/circuits/portcontrol.tar">portcontrol.tar</A> 
package that includes the source code, instructions for compiling/installing and 
instructions for use. For more details check the <A 
href="http://www.epanorama.net/circuits/portcontrol/README">README</A> and the 
<A 
href="http://www.epanorama.net/circuits/portcontrol/portcontrol.c">portcontrol.c 
source code</A>. 
<P>
<H3>Programming tips</H3>
<P>If you want to learn more about I/O port programming I recommend to read <A 
href="http://www.epanorama.net/counter.php?url=http://www.faqs.org/docs/Linux-mini/IO-Port-Programming.html">Linux 
I/O port programming mini-HOWTO</A>. Here are few tips from that document: 
<UL>
  <LI>Routines for accessing I/O ports are in /usr/include/asm/io.h (or 
  linux/include/asm-i386/io.h in the kernel source distribution). The routines 
  there are inline macros, so it is enough to #include <ASM io.h>; you do not 
  need any additional libraries. 
  <LI>Because of a limitation in gcc, you have to compile any source code that 
  uses these routines with optimisation turned on (gcc -O1 or higher), or 
  alternatively use #define extern static before you #include <ASM 
  io.h>(remember to #undef externafterwards). 
  <LI>For debugging, you can use gcc -g -O (at least with modern versions of 
  gcc), though optimisation can sometimes make the debugger behave a bit 
  strangely. 
  <LI>Sometimes it is a good idea to put all I/O port access in a separate 
  source file and compile only that with optimisation turned on. 
  <LI>Before you access any ports, you must give your program permission to do 
  so. This is done by calling the ioperm() function declared in unistd.h, and 
  defined in the kernel) somewhere near the start of your program (before any 
  I/O port accesses). The syntax is ioperm(from, num, turn_on), where from is 
  the first port number to give access to, and num the number of consecutive 
  ports to give access to. ioperm() can only give access to ports 0x000 through 
  0x3ff (or higher ports, you need to use iopl(3) which gives you access to all 
  ports at once). 
  <LI>The ioperm() call requires your program to have root privileges; thus you 
  need to either run it as the root user, or make it setuid root. 
  <LI>You are not required to explicitly drop your port access privileges with 
  ioperm(..., 0) at the end of your program; this is done automatically as the 
  process exits. 
  <LI>You can drop the root privileges after you have called ioperm() to enable 
  the ports you want to use. A setuid() to a non-root user does not disable the 
  port access granted by ioperm(), but a fork() does (the child process does not 
  get access, but the parent retains it). 
  <LI>To input a byte (8 bits) from a port, call inb(port), it returns the byte 
  it got 
  <LI>To output a byte, call outb(value, port) 
  <LI>Note that all port access instructions take at least about a microsecond 
  to execute. 
  <LI>There are manual pages for ioperm(2), iopl(2), and the above macros in 
  reasonably recent releases of the Linux manual page collection 
  <LI>Another way to access I/O ports is to open() /dev/port (a character 
  device, major number 1, minor 4) for reading and/or writing (the stdio f*() 
  functions have internal buffering, so avoid them). Then lseek() to the 
  appropriate byte in the file (file position 0 = port 0x00, file position 1 = 
  port 0x01, and so on), and read() or write() a byte or word from or to it. 
  Naturally, for this to work your program needs read/write access to /dev/port. 
  This method is probably slower than the normal method above, but does not need 
  compiler optimisation nor ioperm(). It doesn't need root access either, if you 
  give a non-root user or group access to /dev/port (potentially dangerous for 
  system security) </LI></UL>
<P>Be warned that this I/O port accessing as decribed above will only work on 
i386 system. To be able to use ioperm you need to include the ncessary headers 
to your software: <PRE>#include <UNISTD.H> /* for libc5 */ 
#include <SYS io.h> /* for glibc */ 
</PRE>The function protype is the following: <PRE>int ioperm(unsigned long from, unsigned long num, int turn_on); 
</PRE>Ioperm sets the port access permission bits for the process for num bytes 
starting from port address from to the value turn_on. The use of ioperm requires 
root privileges. Only the first 0x3ff I/O ports can be specified in this manner. 
For more ports, the iopl function must be used. Permissions are not inherited on 
fork, but on exec they are. This is useful for giving port access permissions to 
non-privileged tasks. This call is mostly for the i386 architecture. On many 
other architectures it does not exist or will always return an error. On 
success, zero is returned. On error, -1 is returned, and errno is set 
appropriately. 
<P>ioperm is Linux specific and should not be used in programs intended to be 
portable. Libc5 treats it as a system call and has a prototype in 
&lt;unistd.h&gt;. Glibc1 does not have a prototype. Glibc2 has a prototype both 
in &lt;sys/io.h&gt; and in &lt;sys/perm.h&gt; (avoid this latter bacause it is 
available on i386 only). 
<P>The I/O accessing can be different on other Linux platforms (for example the 
alpha uses a library, libio, to emulate inb/outb in user programs). 
<P>The description above concentrates on the C programming language. It should 
apply directly to C++ as well. In assembler, you have to call ioperm() or iopl() 
as in C, but after that you can use the I/O port read/write instructions 
directly. 
<P>In other languages, unless you can insert inline assembler or C code into the 
program or use the system calls mentioned above, it is probably easiest to write 
a simple C source file with functions for the I/O port accesses or delays that 
you need, and compile and link it in with the rest of your program. Or use 
/dev/port as described above. 
<P>
<H3>Parallel Port Pin Programming Library for Linux</H3>
<P>If you want a higher level approach to parallel port controlling than low 
level directly writign to control registers apprach, there are also tools for 
this available. <A 
href="http://www.epanorama.net/circuits/>http://www.epanorama.net/counter.php?url=http://parapin.sourceforge.net/">Parapin</A> 
is an easy to use parallel port pin programming library. You can find this 
software at <A 
href="http://www.epanorama.net/counter.php?url=http://parapin.sourceforge.net/">http://www.epanorama.net/counter.php?url=http://parapin.sourceforge.net/</A>. 
Parapin makes it easy to write C code under Linux that controls individual pins 
on a PC parallel port. This kind of control is very useful for electronics 
projects that use the PC's parallel port as a generic digital I/O interface. 
<P>Parapin goes to great lengths to insulate the programmer from the somewhat 
complex parallel port programming interface provided by the PC hardware, making 
it easy to use the parallel port for digital I/O. 
<P>Parapin provides a simple interface that lets programs use pins of the PC 
parallel port as digital inputs or outputs. Parapin makes it easy to write C 
code under Linux that controls individual pins on a PC parallel port. You can 
assert high or low TTL logic values on output pins or poll the state of input 
pins. This kind of control is very useful for electronics projects that use the 
PC's parallel port as a generic digital I/O interface. 
<P>Parapin has two personalities: it can either be used as a user-space C 
library, or linked as part of a Linux kernel module. There is also a device 
driver that provides access to the kernel module from user-space, allowing the 
administrator to use filesystem permissions to control access to the port. 
Parapin was written with efficiency in mind, so that Parapin can be used in 
time-sensitive applications. 
<P>The user-space version of Parapin is compiled and linked very much like any 
other C library. If you installed Parapin on your system using ``make install'', 
the library (libparapin.a) was probably installed in /usr/local/lib. The header 
file with the library's function prototypes and other definitions, parapin.h, is 
probably also in /usr/local/include. To use the library, first make sure to 
#include parapin.h in your C source file. When linking, add -lparapin along with 
any other libraries you might be using. C library initialization is performed 
using the function <PRE>        int pin_init_user(int lp_base);
</PRE>whose single argument, lp_base, specifies the base I/O address of the 
parallel port being controlled. In both the userspace C library version, and the 
kernel version, pins are configured using one of the following three functions: <PRE>        void pin_input_mode(int pins);
        void pin_output_mode(int pins);
        void pin_mode(int pins, int mode);
</PRE>The pins argument of all three functions accepts the LP_PINnn constants 
Once Parapin has been initialized (Section 5), and pins have been configured as 
output pins (Section 6), values can be asserted on those pins using the 
following functions: <PRE>        void set_pin(int pins);
        void clear_pin(int pins);
        void change_pin(int pins, int state);
</PRE>value being asserted by the ``far end'' can be queried using the following 
function. Please note that pin state may only be queried only if they are input 
pins (by hardware or set as input). <PRE>        int pin_is_set(int pins);
</PRE>
<P>If you would like to use the kernel version of parapin from a userspace 
program without writing your own hardware-specific driver, you can load the 
parapindriver module after loading kparapin. This device driver exposes the 
functionality of kparapin through a normal character-device interface (except 
for interrupt handling). The primary advantages are that access to the parallel 
port functionality of parapin may be controlled through /dev filesystem 
permissions, and all interaction is done through standard device-oriented system 
calls such as open(), close(), and ioctl(). When building a userspace program 
that will make use of the parapindriver interface to kparapin, you must include 
parapindriver.h. This header file defines the device-specific ioctl commands 
used to communicate with the device driver. It also includes parapin.h, so your 
program can make use of all the ``LP_*'' constants. The parapindriver system 
calls take arguments using these constants and pass them unchanged down to the 
kparapin routines. 
<P>Once parapindriver is successfully loaded, and a corresponding /dev entry is 
in place, initialization and shutdown of the parallel port are easy. To 
initialize the parapin system, just call open(2) on the /dev entry as you would 
any other device file: <PREA>int device; device = open("/dev/<DEVICE-NAME>", 0); 
if (device &lt; 0) { fprintf(stderr, "device open failed\n"); exit(-1); } <PRE></PRE>The device name is typically parport0, parport1, parport2, etc... (as 
found in Fedora Core 4 Linux system). To shutdown the parapin system you simply 
have to call close(2): <PRE>       close(device);
</PRE>When using the parapindriver device interface, all functionality related 
to pins on the parallel port is invoked via the ioctl(2) system call. The ioctl 
commands for parapindriver are defined in the parapindriver.h header file. The 
two used to set pins to be either output pins or input pins are 
``PPDRV_IOC_PINMODE_OUT'' and ``PPDRV_IOC_PINMODE_IN'', respectively. Examples: <PRE>        ioctl(device, PPDRV_IOC_PINMODE_OUT, LP_PIN01 | LP_PIN02);
        ioctl(device, PPDRV_IOC_PINMODE_IN, LP_PIN11);
</PRE>Setting pin state through the device driver interface follows all the same 
rules as described above. The ioctl commands used are ``PPDRV_IOC_PINSET'' and 
``PPDRV_IOC_PINCLEAR''. <PRE>        ioctl(device, PPDRV_IOC_PINSET, LP_PIN01 | LP_PIN02);
        ioctl(device, PPDRV_IOC_PINCLEAR, LP_PIN01);
</PRE>Querying pin state through the device driver interface follows all the 
same rules as described above. The ioctl command used is ``PPDRV_IOC_PINGET''. 
Please note that pin state may only be queried only if they are input pins (by 
hardware or set as input). <PRE>        int value;
        value = ioctl(device, PPDRV_IOC_PINGET, DATA);
</PRE>Arguments to these ioctl calls use exactly the same constants as are used 
by the userspace and kernel versions of parapin itself. Return values from these 
ioctl calls are the same as those defined for the corresponding functions in 
kparapin (plus value -ENOTTY indicates that an invalid ioctl command value was 
passed down). 
<P>The parallel port pins are accessed with constants in form of LP_PIN plus 
parallel port pin number. For example LP_PIN02 refers to parallel port pin 2 
that is D0 data out pin. Programming tip: Usually, it is most convenient to use 
#define statements to give pins logical names that have meaning in the context 
of your application. Example: <PRE>        #include "parapin.h"

        #define VCC LP_PIN02
        #define CS  LP_PIN03
        #define CLK LP_PIN04
        #define D0  LP_PIN10 /* input pin */
        ...
        clear_pin(CS);  /* pull Chip Select low, tell it to acquire */
        ...
        set_pin(CLK);   /* clock it */
        clear_pin(CLK);
</PRE>
<P>Parapin also supports interrupts through parallel port. Currently, Parapin 
only supports a single parallel port at a time. Many new Linux distributions 
include parport kernel device driver already integrated to the system ready to 
use. 
<P>Parapin docmentation is available at <A 
href="http://www.epanorama.net/counter.php?url=http://parapin.sourceforge.net/doc/parapin.html">http://www.epanorama.net/counter.php?url=http://parapin.sourceforge.net/doc/parapin.html</A>. 
Most of the parapin description give above ade edited form documentation found 
at that address. 
<P>
<H3>Other Linux parallel port controlling software</H3>
<P><A 
href="http://www.epanorama.net/counter.php?url=http://parashell.sourceforge.net/">Parashell</A> 
is a program that allows you to control the parallel port (input and output) 
using simple command line arguments. Due to it's easy interface all you need to 
know is the parallel port's address (ie., 0x378, 0x3bc, etc.) and a little bit 
about binary. This software can be found at <A 
href="http://www.epanorama.net/counter.php?url=http://parashell.sourceforge.net/">http://www.epanorama.net/counter.php?url=http://parashell.sourceforge.net/</A> 
Usage example: <PRE>/usr/local/bin/parashell 0x378 VALUE
</PRE>Where value is the numeric value you want to send to parallel port data 
pins. Parasheel is easy program to use in shell scripts. The software package 
comes with example shell scripts. Parasheel can also be use to read written pin 
states: <PRE>/usr/local/bin/pin 0x378
</PRE>NOTE: You need to have root right to succesfully run parashell programs. 
<P>MatPLC is a program that could be worth to check is also. MatPLC is a 
PLC-like program for Linux (PLC = Programmable Logic Controller), licensed under 
the GNU GPL. The software can control also PC parallel port. MatPLC home page 
can be found at <A 
href="http://www.epanorama.net/counter.php?url=http://mat.sourceforge.net/">http://www.epanorama.net/counter.php?url=http://mat.sourceforge.net/</A>. 

<P>
<H2><A name=webcontrol>Controlling parallel port through web</A></H2>
<P>It is possible to build a system that allows you to control your parallel 
port pins through a web. To do this you need the following parts in your Linux 
system: 
<P>
<UL>
  <LI>A web server software: 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.apache.org/">Apache</A> 
  is the most popular, <A 
  href="http://www.epanorama.net/counter.php?url=http://www.boa.org/">Boa</A> is 
  also possible 
  <LI>The conrolling use interface web pages (you have to make those yourself, 
  possible few web forms with control buttons) 
  <LI>Parallel port controlling CGI-BIN script (you have to write this) 
  <LI>The control program that control parallel port (the Linux controlling 
  program described above is suitable) </LI></UL>
<P>Usually web based I/O-device controlling works in the following way: 
<UL>
  <LI>1. Users downloads a web pages from some page where the web pages is (web 
  browser does this from given addess) 
  <LI>2. The user web browser shows user the downloaded web page that has the 
  control needed (forms, buttons, etc.) 
  <LI>3. User presses some control button or send button on form 
  <LI>4. The user operation at step 3 causes the web browser to send the 
  information (that key has been pressed or form data contents) to the web 
  address given in the web page where this button/form is (can be same or 
  different web server where the form was leaded) 
  <LI>5. A web server in that given address receives the data from user web 
  browser, checks that it correct and sends in some way command to the actual 
  hardware to do whatever needed (this could be call to hardware driver or 
  signaling to some other application running somewhere accessable from web 
  server) </LI></UL>Typically the web based uder interface building can be divided 
to two quite differnet parts: The web interface part (getting the controlling 
information form used to the computer) and the actual hardware controlling 
<P>The first part would include that web server, controlling web pages and 
needed scripts to take user controls. There is a wide selection of suitable 
scripting languages, most attractive for this could be Perl, PHP and UNIX shell 
script (bash). Al those can be used to do to read the user controls. The second 
part needs to be generally written using C language, because most scripting 
languages usually lack the features to do actual direct hardware controlling. 
For this C language is generally the best approach. The idea is tht the actual 
low level hardware controlling is done with simple C program, and then the 
script (on part 1) sends controls to this C program in some way (in simplest 
case runs this C program with right command line arguments every time hardware 
needs to be controlled). 
<P>
<H3>Simple CGI-BIN controlling example</H3>
<P>In this example the idea is that you make a web page that has the control 
buttons what controls you want to do. The control buttons are set so that 
pressing them causes user web browser to send the form contents to a CGI-BIN 
script. This call causes the web server to run the specified CGI-BIN script. The 
CGI-BIN scrips is written to perform the needed controlling, typically calling 
the parallel port controlling program with right parameters. 
<P>This is the basic idea how to do this. 
<P>Here is a simple example web controlling application. Do the following to 
make it work: 
<P>1. Make sure that your system is running <A 
href="http://www.epanorama.net/counter.php?url=http://www.apache.org/">Apache</A> 
web server. Most modern Linux distributions come already with this web server 
software. Make sure you have Apache installed. The flllowing steps expect that 
you run Linux system with correctly configured Apache (Red Hat 7.2 Linux default 
setting are OK). I epect that the web pages related material is located in 
/var/www/ directory (this is typical place on Red Hat Linux systems, on other 
distributions the place can vary, change the examples in this case as needed). 
Make sure that your web server is running. You can start is it for example with 
following command (in most systems you need to be root to do this): <PRE>/sbin/service httpd start
</PRE>Make sure you can access your Linux computer with your web browser 
(running on the same or other computer) when Apache is running on the Linux 
computer. 
<P>2. Compile the <A 
href="http://www.epanorama.net/circuits/weblpt/lptout.c">lptout.c</A> source 
code to lptout binary program, copy the pgoram to /usr/sbin/ directory and set 
rights so that it is always executed as root. You can do this by logging on as 
root and executing the following commands: <PRE>gcc -O lptout.c -o lptout.c
cp lptout /usr/sbin/lptout
chmod +s /usr/sbin/lptout
</PRE>This shoud do this. Now everybody should be able run the command. Test 
this by logging in as somebody else than root and excute the command: <PRE>/usr/sbin/lptout 0xff
</PRE>This should turn on all parallel port LPT1 data pins high (3..5V). 
Executing command <PRE>/usr/sbin/lptout 0xff
</PRE>should turn all output pins low (0..1V). Make sure that this works without 
problems. Test that the port gets really controlled with this program with a 
multimeter or the LED circuit decribed in the beginning of this document. 
<P>3. Install the CGI scripts for parallel port controlling. The need scripts 
are <A href="http://www.epanorama.net/circuits/weblpt/lpton.txt">lpton.cgi</A> 
and <A 
href="http://www.epanorama.net/circuits/weblpt/lptoff.txt">lptoff.cgi</A>. Click 
the file names to see the source code, use "view source" if needed, save those 
files to your system with names lpton.cgi and lptoff.cgi. Then copy those files 
to the web server CGI-BIN directory and give necessary executing rights. Log in 
as root and do the following commands on the diectory where you stored the 
lpton.cgi and lptoff.cgi: <PRE>cp lpton.cgi /var/www/cgi-bin/lpton.cgi
cp lptoff.cgi /var/www/cgi-bin/lptoff.cgi
chmod go+rx /var/www/cgi-bin/lpton.cgi
chmod go+rx /var/www/cgi-bin/lptoff.cgi
</PRE>
<P>4. Install the necessary controlling web page. In this example your 
controllign webpage resides in the web address 
http://www.epanorama.net/counter.php?url=http://yourservernamehere/lpt/index.html 
where the "yourservernamehere" means the name or IP address of your Linux 
computer you run this application at. You need the web page <A 
href="http://www.epanorama.net/circuits/weblpt/index.txt">index.html</A> source 
code (click filename to see the source code, use "view source" if needed ,save 
to your computer as index.html file). To create the web directory for the 
parallel port controlling do the following when logged as root: <PRE>cd /var/www/html/
mkdir lpt
chmod go+rx lpt
</PRE>Now go to the directory where you have the index.html file and copy it to 
the created directory with following commands (still logged in as root) <PRE>cp index.html /var/www/html/lpt/index.html
chmod go+r /var/www/html/lpt/index.html
</PRE>
<P>5. Test that you can access the controlling page on the Linux server. Point 
your web browser to addewss 
http://www.epanorama.net/counter.php?url=http://yourservernamehere/lpt/index.html 
where the "yourservernamehere" means the name or IP address of your Linux 
computer. You should see a controlling page that looks something like this: <IMG 
alt="Web browser view of controlling page" 
src="Parallel port output_files/lptweb.gif"> 
<P>6. Test pressing the control buttons and see that the paralle port output 
pins change their state as controlled. 
<P>You can find all the necessary files for this simple web project at one tar 
file called <A 
href="http://www.epanorama.net/circuits/weblpt/weblpt.tar">weblpt.tar</A>. Just 
download it to your Linux system and expand it to suitable directory with 
command <PRE>tar xvf weblpt.tar
</PRE>Now you have all the files you need. Just do the steps needed with them 
and you should get your simple web controlling application working well. 
<P>NOTE: This a simple example of parallel port controlling through web. This 
example is proably not the most convient or efficent way to do the controlling, 
but has worked for me. When making electronics that is controlled through web, 
you need to always think of the information security related to this, meaning 
that only people whos shoudl be able to do the controlling can do this and 
nobody can easily hack to your system. This method has potanetial security risks 
because the lptout program is always run at root rights (if somebody can make it 
to crash somehow this can potentially cause security problems). To do all the 
steps mentioned in this document you need to be logged as root to the system to 
do what is needed, when you are as root, you can do lots of harm to your system 
if you do stupid mistakes. 
<P>
<H3>Parallel port controlling using PHP</H3>
<P>Here is another source code example for parallel port controlling. This one 
was sent to me by Andrew Nickson to be included in this web page. This is a php 
script which will allow the writing of any data to the parallel port. You need 
to have <A 
href="http://www.epanorama.net/counter.php?url=http://www.apache.org/">Apache</A> 
web server and a decent version of <A 
href="http://www.epanorama.net/counter.php?url=http://www.php.net/">PHP</A> 
installed with Apache. Many Linux distributions include those tools if you have 
selected those to be installed in your system (If you don't have them you need 
to install them). 
<P><IMG alt="Picture of controlling web page" 
src="Parallel port output_files/lptoutphp.gif"> 
<P>There are two files, one the actual php script and the other being the form 
data used to get the users input. For this script to work you need to have the 
same lptout program as used in previous example at your computer at /usr/sbin/ 
directory with enough right that the web server can run it. 
<P>Here is the source code of lptout.php / parallel.php: <PRE>&lt;?php
/* Program: lptout.php
 * Desc:    Takes data from the form and sends it to the 
 *          parallel port program (lptout).
 *			Values should be given in hex (0 - ff)
 *          requires lptout placed in /usr/sbin/
 *          
 *	By Andrew Nickson (www.re-mastered.co.uk)
 */

?&gt;

&lt;?php

  switch (@$_GET['do'])                               
  {

    case "update":
	{
		echo ("&lt;center&gt;&lt;br&gt;Data sent to parallel port (0x$fvalue)&lt;/br&gt;&lt;/center&gt;");

		exec ("/usr/sbin/lptout 0x$fvalue");
		include("parallel.inc");
	}
	break;             

    default:                                             
        include("parallel.inc");
  }
?&gt;
</PRE>
<P>
<P>Here is the source code of parallel.inc file that is used by the previous 
source code. This source code prints out the form that is shown to user for 
parallel port controlling. <PRE>&lt;?php
/* Program: Parallel.inc
 * Desc:    Contains the form data for the parallel control
 *          This will call parallel.php.
 *         
 *	By Andrew Nickson 2005 (www.re-mastered.co.uk)
 */

?&gt;

&lt;html&gt;
&lt;head&gt;&lt;title&gt;Parallel Port Controller&lt;/title&gt;&lt;/head&gt;
&lt;body topmargin="0" leftmargin="0" marginheight="0"
      marginwidth="0"&gt;
         &lt;center&gt;&lt;form action="parallel.php?do=update" method="POST"&gt; 
         &lt;table border="0"&gt;
          &lt;tr&gt;&lt;td align=right&gt;&lt;b&gt;Value (HEX)&lt;/b&gt;&lt;/td&gt;
             &lt;td&gt;&lt;input type="text" name="fvalue" 
                      size="5" maxsize="3"&gt;
             &lt;/td&gt;&lt;/tr&gt;
                &lt;br&gt;&lt;input type="submit" name="Update" 
                           value="Update"&gt;
               &lt;/td&gt;&lt;/tr&gt;
         &lt;/table&gt;
&lt;/body&gt;&lt;/html&gt;

</PRE>
<P>You can donwload the download those source codes as one zipped packet with 
file name <A 
href="http://www.epanorama.net/circuits/lptoutphp.zip">lptoutphp.zip</A>. 
<P>
<H3>Web controlling using PHP and AJAX</H3>
<P>The portcontrol softwae web interface for controlling parallel port is simple 
modern web based interface for controlling parallel port. The software is based 
on PHP software running on Linux server and a JavaScript based client 
application running on the user web browser. With this apprioach it is possible 
to get the almost real-time status of the parallel port data pins to the screen 
nicely and do flexible controlling easily. 
<P>The server end is based on small piece of PHP code and portconrol software. 
portconrol is a simple general purpose I/O port control program for Linux. It 
allows you to write and read the supported I/O ports. The software allows 
writing specified value to port, reading value at given I/O address and printing 
it out to screen in different formats and bit-level manipulation of the port 
data. 
<P><IMG alt="Port control web interface" 
src="Parallel port output_files/portcontrol.gif"> 
<P>The control.php file does the port conrol magic. When it is loaded, the user 
gets a web page plus user end JavaScript code. That JavaScript code periodically 
(once in 5 seconds) asks the parallel port state from the server (AJAX call) and 
if it has changed updates status to the screen. It also handles the control 
buttons. Every control button press makes the control software to call the 
server to make desired function (AJAX call). After controlling is done, the 
server returns the current port status (it is printed to screen). When the 
control software is written in this way, it works prerry well and feels almost 
like a graphical application programs controlling the parallel port directly 
(instead of typical web application that loads web page again and again every 
time you do something). 
<P>Besides the actual controllign PHP script, I have written also an another 
version of the control.php file. This file controlfile.php work pretty much in 
the same way, but instead of controlling parallel port writes and reads the 
status from a file (status.txt in the same directory as the script is). You can 
use it to easily test the AJAX/PHP based control system anuwhere (the computer 
does not need to have any real port in it). The file based AJAX port control 
test application is availble <A 
href="http://www.epanorama.net/circuits/portcontrol/controlfile.php">here</A> 
for you to test. 
<P>The portcontrol software with web interface is is available as <A 
href="http://www.epanorama.net/circuits/portcontrol.tar">portcontrol.tar</A> 
package that includes the source code, instructions for compiling/installing and 
instructions for use. For more details check the <A 
href="http://www.epanorama.net/circuits/portcontrol/README">README</A>. 
<P>To use the software you need to download also <A 
href="http://www.epanorama.net/counter.php?url=http://www.modernmethod.com/sajax/">SAJAX 
Simple Ajax Toolkit by ModernMethod</A> from <A 
href="http://www.epanorama.net/counter.php?url=http://www.modernmethod.com/sajax/">http://www.epanorama.net/counter.php?url=http://www.modernmethod.com/sajax/</A>. 

<P>
<H2><A name=winweb>Web controlling using PHP and AJAX in Windows system</A></H2>
<P>Due several requests I have also made a Windows port of my Web controlling 
using PHP and AJAX system. That Windows version is based on the following 
components: 
<UL>
  <LI>PHP capable web server running on Windows system (I used <A 
  href="http://www.epanorama.net/counter.php?url=http://portablewebap.com/">PortableWebAp</A> 
  version 3.2) 
  <LI>Windows version of my portcontrol sofware (portcontrol.exe) 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.logix4u.net/inpout32.htm">inpout32.dll</A> 
  driver needed by portcontrol.exe to be able to control hardware in Windows 
  NT/2000/XP systems 
  <LI>Slightly modified version of my "Web controlling using PHP and AJAX" PHP 
  scripts. The modifications needed were mostly related to different executable 
  portcontrol program (portcontrol vs. portcontrol.exe) name and different 
  program path (In Windows version executable is in same directory as PHP code) 
  </LI></UL>
<P>To use the package you need to do the following: 
<P>First you need to download <A 
href="http://www.epanorama.net/counter.php?url=http://portablewebap.com/">PortableWebAp</A> 
version 3.2 from <A 
href="http://www.epanorama.net/counter.php?url=http://portablewebap.com/">http://www.epanorama.net/counter.php?url=http://portablewebap.com/</A>. 
This is a free software package, although to get it you need to register first. 
PortableWebAp is a portable platform for web applications. With it you can run 
php web applications from a CDROM, DVD, USB Drive, from any directory from any 
hard drive. No installation is necessary. I selected this packege for the 
simplicity of installation: Just unzip the .zip file to directory you want and 
run it from there. No installation or configuration needed. Size is only around 
5mb. Easiest to set up web server for Windows I have seen! For example install 
this software to directory C:\PortableWebAp3.2 
<P>Then you need to download <A 
href="http://www.epanorama.net/counter.php?url=http://www.logix4u.net/inpout32.htm">inpout32 
driver</A> from <A 
href="http://www.epanorama.net/counter.php?url=http://www.logix4u.net/inpout32.htm">http://www.epanorama.net/counter.php?url=http://www.logix4u.net/inpout32.htm</A>. 
Download the .zip file that contain the driver. Unzip the .zip file to suitable 
directory. Copy inpout32.dll to system directory where the system can find it. 
In my Windows 2000 system suitable directory was C:\WINNT\system32 directory (if 
you use different verwion of WIndows that can be different). 
<P>The third component you need are my PHP script and portcontrol.exe package. 
Download this <A 
href="http://www.epanorama.net/circuits/WinPortControlAjax.zip">WinPortControlAjax.zip</A> 
package <A 
href="http://www.epanorama.net/circuits/WinPortControlAjax.zip">HERE</A>. Just 
download the .zip file. Create a directory named portcontrol under directory 
C:\PortableWebAp3.2\Program\www\localhost. Now you unzip the package to this 
C:\PortableWebAp3.2\Program\www\localhost\portcontrol directory. 
<P>Now you have all the parts needed to set up the system. Next part is testing: 

<P>Start the PortableWebAp by running portablewebap.exe from C:\PortableWebAp3.2 
directory. This will start the web server and also your web browser. If your 
computer has firewall software in it, your firewall software might ask if you 
want this program to be allowed to be run as a service/server (allow that). The 
browser initially points to URL 
http://www.epanorama.net/counter.php?url=http://localhost:800/ . Type in the 
address 
http://www.epanorama.net/counter.php?url=http://localhost:800/portcontrol/control.php 
to your web browser to go to port control application. You have now the same 
looking control screen as in Linux application above. 
<P><IMG alt="Web based port control on Windows" 
src="Parallel port output_files/WinPortControl.gif"> 
<P>This works pretty also on Windows system. There is one downside on the way 
this Windows system is implemented. You seen occasional screen flashing on the 
computer that run the server. This is caused by the portcontrol.exe starting 
every few seconds (started by control.php when web browser AJAX asks for status 
update). Every time portcontrol.exe is started, it's console Window shows up 
(you see the console Window because portcontrol.exe is Windows console 
application), and closes just a fraction of second later. 
<P>
<H2><A name=realworld>Controlling some real world electronics</A></H2>
<P>The idea of the interface shown above can be expanded to control some 
external electronics by simply adding a buffer circuit to the parallel port. The 
programming can be done in exactly the same way as told in my examples. 
<P>
<H2><A name=relaycontrol>Building your own relay controlling circuits</A></H2>
<P>The following circuit is the simples interface you can use to control relay 
from parallel port: 
<P><B><PRE>                             Vcc
                              |
                              +------+
                              |    __|__
                            Relay   /^\  Diode 1N4002
                             Coil  /---\
                              |      |
                              +------+
                              |
                           | / 
                 4.7K    B |/  C
parallel port &gt;-\/\/\/\/---|        NPN Transistor: BC547A or 2N2222A
data pi                    |\  E
                           | V
                             |
parallel port &gt;--------------+
ground pin                   |
                          Ground
</PRE></B>The circuit can handle relays which take currents up to 100 mA and 
operate at 24V or less. The circuit need external power supply which has the 
output voltage which is right for controlling the relay (5..24V depending on 
relay). The transistor does the switching of current and the diode prevent 
spikes from the relay coil form damaging your computer (if you leave the diode 
out, then the transistor and your computer can be damaged). 
<P>Since coils (solenoids and relay coils) have a large amount of inductance, 
when they are released (when the current is cut off) they generate a very large 
voltage spike. Most designs have a diode or crowbar circuit designed to block 
that voltage spike from hitting the rest of the circuit. If that diode is bad, 
then the voltage spike might be destroying your "sink" transistor or even your 
I/O card over a period of time. The mode of failure for the sink transistor 
might be short circuit, and consequently you would have the solenoid tap shorted 
to ground indefinitely. 
<P>The circuit can be also used for controlling other small loads like powerful 
LEDS, lamps and small DC motors. Keep in mind that those devices you plan to 
control directly from the transistor must take less than 100 mA current. 
<P>WARNING: Check and double check the circuit before connecting it to your PC. 
Using wrong type or damaged components can cause you paralllel port get damaged. 
Mistakes in making the circuit can result that you damage your parallel port and 
need to buy a new multi-io card. The 1N4002 diode in parallel with the relay is 
an essential protection component and it should not be left out in acu case, or 
a damage of the parallel port can occur because of high voltage inductive 
kickback from the relay coil (that diode stops that spike from occuring), 
<P>
<H4>Safer new design</H4>
<P>The circuit example above works well and when transistor is of correct type 
and working properly. If for some reason B and C sould be shorted together and 
you are suing more than +5V in the relay side, the circuit can push that higher 
voltage to the parallel port to damage it. The following circuit uses two 1N4148 
diodes to protect parallel port against higher than +5V signals and also against 
wrong polarity signals (power on the circuit is accidentally at wrong polarity. 
<B><PRE>
                             Vcc
                              |
                              +------+
                              |    __|__
                            Relay   /^\  Diode 1N4002
                             Coil  /---\
                              |      |
                              +------+
                              |
          Diode            | /
          1N4148  4.7K   B |/  C
parallel  &gt;-|&gt;|-+--\/\/\/--|        NPN Transistor: BC547A or 2N2222A
port data       |          |\  E
pin             +-|&lt;|-+      | V
            1N4148    |      |
parallel  &gt;-----------+------+
port ground                  |
                          Ground
 
</PRE></B>Adding even more safety idea: Repalce the 1N4148 diode connected to 
ground with 5.1V zener diode. That diode will then protect against overvoltage 
spikes and negative voltage at the same time. 
<P>
<H3>Bad circuit example</H3>
<P>I don't know WHY I see newbies who don't THINK electronics very well yet 
always putting the relay "AFTER" the transistor, as if that was something 
important. Well it's NOT, and in fact its a BAD PRACTICE if you want the 
parallel port to work well! This type of bad circuit designs have been posted to 
the usenet electronics newsgroups very often. The following circuit is example 
of this type of bad circuit design (do not try to build it): 
<P><PRE>                             Vcc
                              |
                           | /
                 4.7K    B |/  C
parallel port---\/\/\/\/---|        NPN Transistor: BC547A or 2N2222A
                           |\  E
                           | V
                             |
                             +------+
                             |    __|__
                           Relay   /^\  Diode 1N4002
                           Coil   /---\
                             |      |
                             +------+
                             |
                           Ground

NOTE: This is a bad design. Do not build or use this circuit.
</PRE>The problem of the circuit is that the voltage which goes to the relay is 
always limited to less than 4.5V even if you use higher Vcc supply. The circuit 
acts like an emitter follower, which causes that the voltage on the emitter is 
always at value base voltage - base to emitter voltage (0.6..0.7V). This means 
that with maximum of 5.1V control voltage you will get maximum of 4.5V out no 
matter what is the supply voltage (when it higher than 5V and below transistor 
breakdown voltage). 
<P>Other problem is that in some cases this type of circuit can start to 
oscillate if the base resistor is right on the edge. 
<P>
<H3>Basic circuit with optoisolation</H3>
<P>One of the simples optoisolated output circuit for parallel port is the 
following 4N33 based circuit: 
<P><IMG alt="4N33 based parallel port optoisolator" 
src="Parallel port output_files/4N33out.gif"> 
<P>The <A 
href="http://www.epanorama.net/counter.php?url=http://www.fairchildsemi.com/pf/4N/4N33.html">4N33</A> 
optocouplet device has a Darlington output transistor that is capable of driving 
up to 30 mA of load safely. The maximum voltage on the output side is 30V. The 
input to output isolation can handle up to 1500V voltage. You connect the input 
side + to the parallel port output pin you want to use for the controlling. Then 
you connect the input - side to parallel port ground pin. The output side is 
connected to the circuit to be controlled at right polarity. This example 
cirucit used 1 kohm resistor to limit the control current current (circuit 
should also work well with 470 ohm resistor). Because the current fed to the 
optocoupler is very low (just few mA), the guaranteed outptu current available 
from the optocoupler is low. You can expect to get something like 10 mA of drive 
capacity on output (maybe more if you are lucky to have a coupler with high CTR 
and parallel port with high output current). The circuit can be built also using 
4N32 optocoupler that is very similar to 4N33. 
<P>4N33 component data: 
<UL>
  <LI>The 4N32 and 4N33 are optically coupled isolators with a gallium arsenide 
  infrared LED and a solicon photodarlington sensor. 
  <LI>Switching can be achieved while maintaining a high degree of isolation 
  between driving and load circuits. 
  <LI>Very high current transfer ratio, 500 % Min. 
  <LI>High isolation resistance 
  <LI>Forward continuous current maximum 60 mA 
  <LI>Output Collector-emitter breakdown voltage 30V 
  <LI>Output can easily drive 50 mA current 
  <LI>Output Power dissipation maximum 150 mW 
  <LI>Isolation test voltage 5300V </LI></UL>The component data is taken from 
datasheet available at <A 
href="http://www.epanorama.net/counter.php?url=http://www.vishay.com/docs/83736/83736.pdf">http://www.epanorama.net/counter.php?url=http://www.vishay.com/docs/83736/83736.pdf</A>. 
These optocouplers can be used to replace reed and mercury relays with 
advantages of long life, high speed switching and elimination of magnetic 
fields. 
<P>
<H3>Transistor amplified optocoupler circuit</H3>
<P>If you want to have a very good protection and of the parallel port and more 
drive capacity you might consider optoisolation using the following type of 
circuit: <B><PRE>
                                                V+  (12V)
                                                 |
                                    +------------+
                                    |            +------+
Parallel                            |            |      |
Port                                |    D1     ---     |
                                    |   1N4001  / \    Relay coil
          R1    1  ----------- 5    |          /---\    |
 D(x) ----1k------| Opto-     |-----+            |      |
                  | Isolator  |                  +------+
 GND -------------|           |-+                |
                2  ----------- 4|                |
                   CNY 17 or    |   R2        | /
                   4N25         |   4.7K    B |/  C   T1
                                +--\/\/\/\/---|      BC547A or 2N2222A
                                              |\  E
                                              | V
                                                |
                                          external circuit ground
</PRE></B>Typical optoisolator pinout (CNY 17 and 4N25): <PRE>
    -----------------------------
 1--|----          |------------|--6
    |   |          |            |
    | \---/ \      |    ------  |
    |  \ /  \     | | / C   |  |
    |  --- \  \|   | |/     |  |
    |   |   \ --   --|       ---|--5
    |   |    \|    B |\         |
 2--|----    --      | V E      |
    |                   --------|--4
 3--|--NC                       |
    -----------------------------

</PRE>
<P>The opto-isolator is there to protect the port. Note that there are no 
connections between the port's electrical contacts. The circuit is powered from 
external power supply which is not connected to PC if there is no need for that. 
This arrangement prevents any currents on the external circuits from damaging 
the parallel port. 
<P>The opto-isolator's input is a light emitting diode.R1 is used to limit the 
current when the output from the port is on. That 1kohm resistor limits the 
current to around 3 mA, which is well sufficent for that output transitor 
driving. 
<P>The output side of the opto-isolator is just like a transistor, with the 
collector at the top of the circuit and the emitter at the bottom. When the 
output is turned on (by the input light from the internal LED in the 
opto-coupler), current flows through the resistor and into the transistor, 
turning it on. This allows current to flow into the relay The output current 
from the optoisolator with the input current listed above should be around 1-3 
mA range (depends on exact optisolator type and component variations). This 
current goes through R2 to the transisto base. 
<P>Turning the input on the parallel port off causes the output of the 
opto-isolator to turn off, so no current flows through it into the transistor 
and the transistor turns off. When transistor is off no current flows into the 
relay, so it switches off. The diode provides an outlet for the energy stored in 
the coil, preventing the relay from backfeeding the circuit in an undesired 
manner. 
<P>The transistor in the circuit can be used for controlling output loads to 
maximum of around 100 mA (depends somewhat on components and operation voltage 
used). The external power supply can be in 5V to 24V range. When you use a relay 
that takes less than this 100 mA of current and works at the power supply you 
use, you should be OK. The output load that you can control with the circuit 
with a relay only depends on the relay output contact ratings (maximum current 
and maximum voltage). 
<P>The circuit ban be used also directly to control small loads (less than 100 
mA current). Just put the load you want to control in place of the relay coil. 
<P>Some component data on the components used: 
<UL>
  <LI>2N2222A: NPN transistor, T018 case, Vce=40V, Vcb=75V, Ic=800mA, 
  Hfe=100-300, 300MHz, 500mW 
  <LI>BC547A: NPN transistor on TO92 case, Vce=45V, Vcb=50V, Ic=100mA, 
  Hfe=110-800, 300MHz, 625mW 
  <LI>CNY17: Optocoupler with Phototransistor Output, CTR from 40% to 200% 
  depending on version, 4400 Vdc isolation 
  <LI>4N25: optocoupler with phototransistor output, CTR typically 50% (20% 
  minimum), 2500V isolation, input forward current max 80 mA, 30V max output 
  voltage </LI></UL>
<P>
<H3>Optoisolated high power control circuit</H3>
<P>Here is a higher power version of the circuit described above: 
<P><B><PRE>
                                                V+  (12V)
                                                 |
                                    +------------+-----+------+
                                    |                  |      |
Parallel                            |                  |      |
Port                                |          D1     ---     |
                                    |         1N4001  / \    Relay coil
          R1     1 ----------- 5    |                /---\    |
 D(x) ----1k------| Opto-     |-----+                  |      |
                  | Isolator  |                  +-----+------+
 GND -------------|           |-+                |            |
                 2 ----------- 4|                |            |
                   CNY 17 or    |   R2        | /             |
                   4N25         |   4.7K    B |/  C T1        |
                                +--\/\/\/\/---|     BC547A    |
                                |             |\  E           |
                                |             | V          | /
                                /               |        B |/C  T2
                                \  R3           +----------|    power
                                / 10 kohm                  |\E  transistor
                                \                          | v
                                |                            |
                                +----------------------------+
                                                             |
                                                external circuit ground
</PRE></B>In this circuit Q1 is used for controlling the base current of Q2 
which controls the actual current. You can select almost any general purpose 
power transistor for this circuit which matches your current and voltage 
controlling needs. Some example alternatives are for example TIP41C (6A 100V) or 
2N3055 (100V 15A). Depending your amplification facter inherint to the transitor 
Q2 you might not hough be able to use the full current capability of the output 
device T2 before there will be excessive losses (heating) in that transistor. 
<P>This circuit is basically very simple modification of the original 
optoisolator circuit with one transistor. The difference in this circuit is that 
here T2 controls the load current and Q1 acts as a current amplifier for T2 base 
control current. Optoisolator, R1, R2, Q1, D1 work exactly in the same way as in 
one transistor circuit described eariler in this documents. R3 acts like an 
extra resistor which guarantees that T2 does not conduct when there is no signal 
fed to the optoisolator (small possible current leaking on optosiolator output 
does not make T1 and T2 to conduct). 
<P>
<H2><A name=mainspower>Mains power controlling with parallel port</A></H2>
<P>It is possible to control mains voltage through parallel port with a suitable 
circuit. When controlling mains voltage, you need to be varycarefyl and know 
what you do to do it safely. Mains voltage can kill if you get in touch with it, 
and bad mains controlling circuit can burn down your house. 
<P>First idea for controlling mains power is to use one of the circuit above to 
control a relay that then controls the mains power. This suits for many 
applications as long as the relay is rated for the mains power switching 
applications and for the current rating of your applications. The relay contact 
is used to switch the phase/live wire going to the equiment. A properly designed 
circuit should have in addition to the relay (plus parallel port interface 
circuit) also a peoprly sized fuse that will cut the power going through the 
relay in case of short circuit or overload at the equipment being controlled. 
The fuse here is used to protect the relay against overload. A relay will work 
on applications where the device is turned on and off quire rarely. If you are 
switchign the device on and off often, the normal relay will siffer of limited 
mechanical and electrical age, and in some applications also on noise caused by 
sparks that are formed when relay contacts open and close. Those sparks can 
cause radio frequncy noise. 
<P>Another component suitable for mains voltage controlling is a solid state 
relay. The circuit show below describes how to control a solid state relay from 
PC parallel port. The solid state relay controls the mains voltage. 
<P><IMG alt="Mains power controlling with solid state relay" 
src="Parallel port output_files/lpt_ssr.gif"> 
<P>The relay for this application should be sone rated for the mains voltage you 
used and the current your controlled equipment (marked with L on the picture) 
takes. The solid state relays designed for mains operation provide the needed 
isolation between the control input and mains side. The solid state relay should 
be used according the manufacturer application notes and your local electrical 
equipment codes. You should keep the mains side and low voltage side isolated in 
all cases (even on equipment damage case). You should also put a properly rated 
fuse in series with the solid state relay so protect the relay against overload. 
A proper size fuse will not protect the solid state relay against overheating of 
the load tries to take too much current through the relay. The fuse might not ne 
able to protect the relay agains short circuit damages (if you short-circuit the 
load, you generally loose the solid state relay and the fuse). 
<P>Many solid state relays can be controlled directly to parallel port without 
extra components. You need to select a solid state relay that is voltage 
controlled and the control voltage range can take the voltage that printer port 
outputs (5V or somewhat less). For reliable operation you should select a relay 
that can operate at down to 3V input voltages and does not take too much control 
current (a SSR that takes only few milliampreres is preferred because current 
output capacity of parallel port is usually limited to that). To gurarantee that 
the operation is reliable with the direct connection, be sure to measure that 
the control vontage entering the SSR is within the specified operating range 
when the relay is controlled to parallel port (you can measure this without 
mains power applied to the rest of circuit, safer o measure in this way). 
Controlling a solid state relay with lower than specified control voltage can 
lead unreliable operation of solid state relay, and can even cause some solid 
state relays fail when heavily loaded! 
<P>It is also possible to build the mains voltage controlling part from discrete 
components. Here are two example cirucuits: 
<P><IMG alt="110V AC controlling" src="Parallel port output_files/moc3012.gif"> 
<P><IMG alt="220V AC controlling" 
src="Parallel port output_files/lpt_TRIAC.gif"> 
<P>Those are just as an example. I do not recommend you to build those circuits. 
Nowadays the solid state relays are available at reasonable prices, and with 
them it is easier to build safe controlling circuits. 
<P>One very important thing to note on mains controlling circuits is that they 
should be built very carefully and right. Mains voltage can kill if you come in 
touch with it. A baddly constructed circuit can overheat and cause fire. Any 
mains controlling circuit should be built in such way that there is an 
overcurrent protection component that protects the circuit against overloads 
(usually a fuse in the power input). The circuit must be built into a safe and 
mechanically stable case. An insulating plastic case (electronics case made from 
plastic that does not burn easily) is one option. Another option is to built the 
circuit into a gounded metal case. The exact practices how to build safe mains 
powered circuits is outside the scope of this article. You should know those 
details before attempting to built any ciruit that connects directly to mains 
power. 
<P>
<H2><A name=multiout>Compact 8 channel output driver</A></H2>
<P>You can build a circuit with many outputs by conbiming many individual 
transistor based circuits. If you want to hve a compact construction with up to 
8 outputs, I would recommend you to consider using ULN2803 IC that is 
manufactured by <A 
href="http://www.epanorama.net/counter.php?url=http://www.allegromicro.com/">Allegro</A> 
and several other manufacturers. Here is the pinput of this ULN203 IC: 
<P><IMG alt="ULN2803 pinout" src="Parallel port output_files/ULN2803.gif"> 
<P>ULN2803 is a 8-bit 50V 500mA TTL-input NPN darlington driver. Featuring 
continuous load current ratings to 500 mA for each of the drivers, the ULN2803A 
high-current Darlington array is ideally suited for interfacing between 
low-level logic circuitry and multiple peripheral power loads. Typical loads 
include relays, solenoids, stepping motors, magnetic print hammers, multiplexed 
LED and incandescent displays, and heaters. The drivers need no power supply; 
the VDD "common" pin is the common cathode of the eight integrated protection 
diodes. The data sheet for this IC can be found at <A 
href="http://www.epanorama.net/counter.php?url=http://www.allegromicro.com/sf/2801/">http://www.epanorama.net/counter.php?url=http://www.allegromicro.com/sf/2801/</A> 
and <A 
href="http://www.epanorama.net/counter.php?url=http://impressolibre.sourceforge.net/miniplotter/ULN2803-D.PDF">http://www.epanorama.net/counter.php?url=http://impressolibre.sourceforge.net/miniplotter/ULN2803-D.PDF</A> 

<P>The ULN2803 is connected between each of the eight 'output' lines of the 
printer port and the device it controls. The output 'device' can be as simple as 
a LED, a small motor, or a relay. The inputs on the left side of the IC are 
directly suitable to be connected to PC parallel port output lines. The outputs 
are open collector output (output gets grounded through transistor when 
corresponding input line goes to high state), so they are well suitable for 
controlling various loads powered through external power supply. The maximum 
controllable voltage is 50V and maximum current per channel is 500 mA. Outputs 
may be paralleled for higher load current capability. The input and output sides 
of the IC have the same common ground that must be connected also to the ULN2803 
IC ground pin. 
<P>The "common" line is connected to a suitable overvoltage protection circuitry 
to prevent damage to the IC due to "back emf" when loads such as motors and 
relays switch on and off. This "common" line can be for example connected to the 
power supply line that supplies power to the relays. You can also use for 
example 30V zener connected to this line as protetion component (limits relay 
power supply to maximum less than 30V). Or you can connect a 12V zener rfom 
common to the relay power supply plus (limits spikes to power supply voltage 
plus 12V, do not use higher than 30V power supply). 
<P>Here is an example of control circuit that drives eight LEDs using ULN2803 
IC: 
<P><IMG alt="Driving LEDs with ULN2803" 
src="Parallel port output_files/uln2803circuit.gif"> 
<P>This circuit can be also used to drive other kinds of loads, for example 
relays, small light bulbs etc. Just replace the LED plus resistor combination 
with the load you want (as long as the load is within the capabilities of the 
ULN2803 output drive capacity). You can use for example 15V zener diode for this 
ciruit. 
<P>Other examples of circuits implemented with ULN2803 can be found at <A 
href="http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/electronics/integrated.htm">http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/electronics/integrated.htm</A> 
and <A 
href="http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/sio5works.htm">http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/sio5works.htm</A>. 

<P>
<H2><A name=circuitlinks>Links to parallel port output circuits</A></H2>
<P>
<H3>Circuit diagram links</H3>
<UL>
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/electronics/integrated.htm">Connecting 
  the ULN2803 to the Printer Port</A> 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://electronickits.com/kit/complete/elec/ck1601.htm">PARALLEL 
  PORT RELAY BOARD</A> - There are 8 relays each capable of switching 12VDC/10A 
  or 240VAC/5A. This is sold as a kit with full details on the documentation. 
  This page gives you control software for download. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://ourworld.compuserve.com/homepages/Bill_Bowden/page6.htm">Parallel 
  Port Relay Interface</A> - three examples of controlling a relay from the PC's 
  parallel printer port 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/sio5works.htm">The 
  Simplified I/O Interface - How it Works</A> - In this application of the 
  ULN2803 IC, small currents available at the Printer Port are used to control 
  devices that could not be connected directly to the Port, such as motors and 
  relays. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.doc.ic.ac.uk/~ih/doc/stepper/control2/connect.html">Stepper 
  Motor Controller Connection Diagrams</A> 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.dakeng.com/relay.htm">Relay 
  control</A> - The question of how to connect and control a relay from the 
  parallel port came up. Here's how you can do it, even if you don't know a lot 
  about electronics! 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/sio.html">Simplified 
  Output Interface</A> - is a simple and inexpensive output control interface 
  for the Centronics printer port. Final cost per interface is less than $30. 
  The integrated circuit (IC) used is an eight line "Darlington Driver" coded 
  ULN2803. The digital state of each of the eight lines from the printer port is 
  used to control the IC's internal "drivers" which in turn control the LEDs. 
  Power for the LEDs is provided by the external battery. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/4x4.html">Four-Way 
  I/O</A> is a simple and inexpensive 4-way input/output interface for the 
  Centronics printer port. The output section is controlled by an eight line 
  "Darlington Driver" integrated circuit (IC) called a ULN2803. The digital 
  state of each of the eight lines from the printer port is used to control the 
  IC's internal "drivers" which in turn control the Relays and LEDs. Power for 
  the Relays and LEDs is provided by the 12 volt regulator (LM 7812) via a plug 
  pack power supply. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/8way.html">The 
  8-Way Relay Board</A> controls 8 relays using ULN2803 IC. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/noalimba/noalimba1.htm">A 
  Single-Channel Control Line</A> is a very simple relay controlling board that 
  controls to parallel port. The aim was to develop a circuit simple enough to 
  be manufactured 'from the ground up' on the first day of the weekend and then 
  spend the second day developing software to run it. This circuit is based on 
  one transistor controlling a relay. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://ourworld.compuserve.com/homepages/Bill_Bowden/page6.htm">Parallel 
  Port Relay Interface</A> gives examples of controlling a relay from the PC's 
  parallel printer port (LPT1 or LPT2). There are examples for a solid state 
  relay and normal relay controlling. Also parallel port reading is covered. 
  </LI></UL>
<P>
<H3>Propably useful kit / module products</H3>
<P>The following electronics kits are believed to be useful to the readers that 
do not want to build their interfacing electronics from scratch. Those modules / 
kits should all be controllable in the same way as my examples above have 
described the parallel port use. I have personally tested Kemo M125. Information 
on other products are based on looking at their circuit diagrams and/or control 
software operation. 
<P>
<UL>
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://brinck.dk/byggesaet/br848.asp">Br 
  848 8 Kanals Parallelport Styring</A> - This kit is a 8 channel optoisolated 
  open collector output card for PC. The product web page has downloadable 
  contro software for Win-XP/2000. Software comes with some source code 
  examples. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.kemo-electronic.com/en/bausaetze/b210/index.htm">Kemo 
  B210</A> - 8-Channel-relay board for switching different appliances, lamps or 
  motors by means of a computer program. The relay points can be loaded up to 3A 
  25V each at maximum. Operating voltage of the relay board: 12V DC 0.8A. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.kemo-electronic.com/en/module/m104/index.htm">Kemo 
  M104</A> - 4-Channel computer switch for switching up to 4 different 
  appliances, lamps or motors by means of a computer program. Consumers with 
  operating voltages of 6...24V, max. 2A total direct current can be controlled. 
  This module handles only 4 first outputs. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.kemo-electronic.com/en/module/m125/">Kemo 
  M125</A> - Relay module for switching up to 8 different appliances, lamps or 
  motors according to a computer program (software is enclosed). The installed 
  solid-state-relays may switch voltages up to 40V and loads up to 0,4A (DC) or 
  0,2A (AC). There is control software downloadable for DOS and Windows. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://electronickits.com/kit/complete/elec/ck1601.htm">PARALLEL 
  PORT RELAY BOARD</A> - There are 8 relays each capable of switching 12VDC/10A 
  or 240VAC/5A. This is sold as a kit with full details on the documentation. 
  This page gives you control software for download. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.velleman.be/common/product.Aspx?lan=1&amp;id=9071">K2634 
  QUAD TRIAC SWITCH CARD</A> - Relays are usually used to switch AC voltages by 
  means of an electronic control because of their simplicity. However, when 
  switching occurs too frequently or too quickly the life time of the contact 
  points is shortened considerably. This can be solved perfectly by replacing 
  the relays with a triac. Using optocouplers, the entire interface network 
  remains electrically isolated from the voltage that has to be switched. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/prices.htm">Robotics 
  Resources</A> offers Simplified I/O Interface and 8 Way Relay Board in kit 
  form. </LI></UL>
<P>
<H2><A name=controlsoftware>Ready made control software</A></H2>
<P>Here is a colelction of links to ready made parallel port control software. 
There is a wide varietyof different software available for different operating 
systems and different use. Pick up one that suits best for your uses. 
<P>
<UL>
  <LI>Kemo M125 kit web page at <A 
  href="http://www.epanorama.net/counter.php?url=http://www.kemo-electronic.com/en/module/m125/">http://www.epanorama.net/counter.php?url=http://www.kemo-electronic.com/en/module/m125/</A> 
  has control software available for download. Those software allows controlling 
  of outputs manually and timed operation. Windows software runs in WIN9x, WIN2K 
  and WINXP. There is also programming C source code example available. 
  <LI>Parallel port relay relay board kit described at <A 
  href="http://www.epanorama.net/counter.php?url=http://electronickits.com/kit/complete/elec/ck1601.htm">http://www.epanorama.net/counter.php?url=http://electronickits.com/kit/complete/elec/ck1601.htm</A> 
  comes with Windows and DOS control software that can be downloaded at the kit 
  page. This software runs at Windows 9x/2000/ME/XP. 
  <LI>Parallel port relay relay board kit described at <A 
  href="http://www.epanorama.net/counter.php?url=http://electronickits.com/kit/complete/elec/ck1601.htm">http://www.epanorama.net/counter.php?url=http://electronickits.com/kit/complete/elec/ck1601.htm</A> 
  comes with Windows and DOS control software that can be downloaded at the kit 
  page. Documentation for DOS utilities that come with package can be found at 
  <A 
  href="http://www.epanorama.net/counter.php?url=http://www.qkits.com/serv/qkits/diy/pages/QK74.asp">http://www.epanorama.net/counter.php?url=http://www.qkits.com/serv/qkits/diy/pages/QK74.asp</A>. 

  <LI>Parallel port monitors page at <A 
  href="http://www.epanorama.net/counter.php?url=http://neil.fraser.name/software/lpt/">http://www.epanorama.net/counter.php?url=http://neil.fraser.name/software/lpt/</A> 
  has programs that allow you to set and monitor parallel port pin states. The 
  software is available for few different versions that work on Windows 98 / ME 
  / NT / 2000 / XP and DOS / Windows 3.1 / 95 / 98 / ME systems. The software is 
  written using Visual Basic and Euphoria programming languages and comes with 
  source code. 
  <LI>DMXcontrol Show Control software at <A 
  href="http://www.epanorama.net/counter.php?url=http://www.dmxcontrol.de/">http://www.epanorama.net/counter.php?url=http://www.dmxcontrol.de/</A> 
  is designed to control lighting instruments connected to DMX-512 bus. In 
  addition to different DMX-512 interface drivers, this software comes also with 
  simple parallel port driver called Parallelport. This Parallelport driver maps 
  12 first control channels to parallel port output pins (8 first come to data 
  lines as the circuits in this document uses, rest go to parallel port control 
  output lines). You just define each pin you want to control to be "Generic 
  Dimmer" and use the light controlling interface sliders to control parallel 
  port pins freely: putting the control slider below center point keeps 
  corresponding output low (logic 0), and above center point sets the output 
  high (logic 1). Other option is to set the pins you wnat to control as 
  "Generic OnOff", and now the control has one on/off button that changes it's 
  state when presses. DMXcontrol software works on Windows systems. This 
  software supports Sound-to-Light functions ("light organ-effects") when 
  connected with audio-program Winamp (www.winamp.com). You need to install the 
  Driverlinx PortIO (link provided on software download page) to make parallel 
  port to work. 
  <LI>MatPLC at <A 
  href="http://www.epanorama.net/counter.php?url=http://mat.sourceforge.net/">http://www.epanorama.net/counter.php?url=http://mat.sourceforge.net/</A> 
  is a PLC-like program for Linux (PLC = Programmable Logic Controller), 
  licensed under the GNU GPL. This software supports controlling of the parallel 
  port output pins according your control program (can be written with C, Python 
  or several IEC61131 control languages). This is worth to check if you are 
  thinking of industrial automation applications. This software comes with 
  source code. This software runs on Linux system. 
  <LI>Parallel Port Debug Tool at <A 
  href="http://www.epanorama.net/counter.php?url=http://www.beyondlogic.org/pardebug/pdebug.htm">http://www.epanorama.net/counter.php?url=http://www.beyondlogic.org/pardebug/pdebug.htm</A> 
  is a handy DOS utility when debugging devices connected to the Parallel Port. 
  It gives a visual display of the three software registers used by the Standard 
  Parallel Port. Each individual bit can be turned on or off by a simple click 
  of the mouse. This software comes with source code. </LI></UL>
<H2><A name=controloutput>Using control outputs</A></H2>
<P>In addition to the data pins the parallel port has four other output pins. 
Those are handshake pins STROBE (pin 1), AF (pin 14), RESET (pin 16) and SELECT 
(pint 17). Those outputs give TTL level signals, but are constructed 
electrically differently and controlled with a different control register. 
<P>The control outputs are generally constructed as open collector output with 
internal pull-up resistor. 
<P><PRE>         +5
         |
       4.7 kohm
         |     
         |________  TTL output
         |   out  
        /         
    ---L off      
        \
         |
        Gnd
</PRE>
<P>This kind of ouputs can't source much of anything (about 1 mA through the 
4.7K resistors to +5), and can only sink about 7mA. This kind of output can 
control TTL inputs fine, and might be able to run an optocoupler or solid state 
relay in sink mode (depends on the device). 
<P>The programming of the parallel port control registers is made by wrting 
suitable values to the hanshake linke control regsiter (parallel port I/O 
address plus two). More details on the parallel port register summary later in 
this document. 
<P>Note: There can be somewhat different implementations on some PCs. For 
example once very popular (many years ago) UM82C11-C chip implements the control 
outputs as standard TTL outputs with lower (1.5 mA) current capacity instead of 
traditional open collector circuit with pull-up resistors. 
<P>
<H2><A name=input>Reading the input pins in parallel port input pins</A></H2>
<P>PC parallel port has 5 input pins. Those inputs can accept TTL level signals 
(0-0.7V = logic 0, 2.4-5V = logic 1). You can connect a TTL level output signal 
to it directly (remeber to attach the signal source ground to parallel port 
ground). You can connect siple switches to the inputs by connecting the switch 
bbetween parallel port ground and input pin, and then adding a 10 kohm pull-up 
resistor from the pin to +5V. When the switch is activated, the pin goes to 
logic state 0. Usually it is a good idea to isolate the PC from the signal 
source, and in this case it is usually a good idea to use a relay or optocoupler 
(the relay/optocoupler output is wired in the place of the switch, otherwise 
works in the same way as the switch connection). 
<P>TIP: You can avoid using external +5V power source by using one of the 
parallel port output pins as one. So set one free output pin to logic 1 and wire 
the 10 kohm pull-up resistors to it instead of dedicated extra +5V source. For 
other ideas how to get that +5V power take a look at <A 
href='http://www.epanorama.net/circuits/power_from_pc.html"'>How to get power 
from PC to your circuits</A> and <A 
href="http://www.epanorama.net/circuits/psu_5v.html">Simple 5V power supply for 
digital circuits</A>. 
<P>The input pins can be read from the I/O address LPT port base address + 1. 
<P>The meaning of the buts in byte you read from that I/O port: 
<UL>
  <LI>D0: state not specified 
  <LI>D1: state not specified 
  <LI>D2: state not specified 
  <LI>D3: state of pin 15 (ERROR) inverted 
  <LI>D4: state of pin 13 (SELECTED) 
  <LI>D5: state of pin 12 (PAPER OUT) 
  <LI>D6: state of pin 10 (ACK) 
  <LI>D7: state of pin 11 (BUSY) inverted </LI></UL>Here are some code snipplets 
to read LPT port: 
<P>
<H3>Assembler</H3><PRE>MOV DX,0379H
IN AL,DX
</PRE>You get the result fo read from AL register 
<P>
<H3>BASIC</H3><PRE>N = INP(&amp;H379);
</PRE>Where N is the numerical value you read. 
<P>
<H3>C</H3><PRE>in = inportb(0x379);
</PRE>or <PRE>in = inp(0x379);
</PRE>Where N is the data you want to output. The actual I/O port controlling 
command varies from compiler to compiler because it is not part of standardized 
C libraries. 
<P>
<P>Here is a Linux reading program example that reads the state of parallel port 
input pins: <PRE>
#include <STDIO.H>
#include <STDLIB.H>
#include <UNISTD.H>
#include <ASM io.h>

#define base 0x379           /* I/O address to read */

main(int argc, char **argv)
{
  int value;

  if (ioperm(base,1,1))
    fprintf(stderr, "Couldn't get the port at %x\n", base), exit(1);

  value = inb(base);
  printf("Port 0x%x read value is %i \n",base,value);
}

 
/* compile with  command line
  gcc -O lpt_read.c -o lpt_read */

</PRE>The user has to have the previledges to have access to the ports for the 
program to run, so you have to be root to be able to ron this kind of programs 
without access problems. If you want to make a program which can be run by 
anybody then you have to first set the owner of the program to be root (for 
example do compilation when yhou are root), give the users rights to execute the 
program and then set the program to be always executed with owner (root) rights 
instead of the right of the user who runs it. You can set the programn to be run 
on owner rights by using following command: <PRE>chmod +s lpt_read
</PRE>
<P>
<H3>Input circuits</H3>
<P>There are several ways to sense external switches via a parallel printer 
port. The input pins on parallel port take TTL level signals (0V to 5V). You can 
wire simple switches to this input with the following circuitry. 
<P><PRE>                        4.7K
         Input -------+-^^^^^--- (+5 v)     
                      |
                    switch
		      |
         Ground ------+---------- (gnd)
</PRE>
<P>THis circuit uses resistors (4.7K) from the Status inputs to +5 volts, and 
use switches to pull these down to ground. If you want to use all five inputs, 
build five circuits to different pins. One disadvantage of this is that it uses 
an external +5 supply. If you have spare not used data output pins free, you can 
set them to might and use them as the +5V source for this circuit (one data 
output can power several switch circuits like this). 
<P>TTL inputs in the parallel port tend somewhat to float high, so you might get 
by without the pullup resistors, but you are pushing it (might not work 
reliably). 
<P><PRE>        Input  ------+
                     |
                   switch
		     |
        Ground ------+
</PRE>
<P>Example circuit fror five channel parallel port input circuit for switches. 
This circuit used 3 kohm pull-up resistors and extra 330 "safety" resistors 
between the parallel port and rest of the circuit. 
<P><IMG alt="Five switches to parallel port circuit" 
src="Parallel port output_files/parallel_input.gif"> 
<P>You can modify those circuit ideas for other applications as well. You can 
for example replace the switch in the circuit with a relay output contact or 
optocoupler output side. In this way you can get signals nicely to the PC and 
keep the PC isolated from your control circuitry. 
<P>The following circuits can be used isolate external when connecting to 
parallel port. Wire the output side of the optocoupler (on the right side) to 
the parallel port input circuit in place of the switch in the circuit above. If 
you wish the control from both switch and external signal, you can wire he 
optocoupler output in parallel with the switch in the circuit. Please note to 
put the optocoupler out - wire to the side that connects to the circuit ground 
(if you wire optocoupler the wrong way they wil not work). 
<P><IMG alt="4N33 optoisolator" src="Parallel port output_files/4N33out.gif"> 
<P><PRE>                                    out +  
          R1    1  ----------- 5    |    
 in+  ----1k------| Opto-     |-----+    
                  | Isolator  |          
 in- -------------|           |-+        
                2  ----------- 4|        
                   CNY 17 or    | 
                   4N25         | 
                               out -
                              (wire to ground)
</PRE>
<P>The input voltage that you can feed to the input of the optocoupler can be 
from few volts to 30 volts. The minumum voltage the circuit starts to activate 
the the printer port signal varies depending on used optocoupler (generally from 
few volts up, input voltage below 1V will not activate port for sure). Be 
careful to feed the input signal at right polarity to the optocoupler input 
(wrong polarity signal can damage optocoupler). 
<P>
<H3>Parallel port intput circuit example links</H3>
<UL>
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://courses.ece.uiuc.edu/ece390/resources/parallel.html">Your 
  PC's Printer Port: a Window on the Real World</A> 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://ourworld.compuserve.com/homepages/Bill_Bowden/page6.htm">Parallel 
  Port Relay Interface</A> gives examples of controlling a relay from the PC's 
  parallel printer port (LPT1 or LPT2). There are examples for a solid state 
  relay and normal relay controlling. Also parallel port reading is covered. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.southwest.com.au/~jfuller/4x4.html">Four-Way 
  I/O</A> is a simple and inexpensive 4-way input/output interface for the 
  Centronics printer port. The output section is controlled by an eight line 
  "Darlington Driver" integrated circuit (IC) called a ULN2803. The digital 
  state of each of the eight lines from the printer port is used to control the 
  IC's internal "drivers" which in turn control the Relays and LEDs. Power for 
  the Relays and LEDs is provided by the 12 volt regulator (LM 7812) via a plug 
  pack power supply. There is a four channel input for switch status 
  information. </LI></UL>
<P>
<H3>Ready made reading software</H3>
<P>Parallel port monitors page at <A 
href="http://www.epanorama.net/counter.php?url=http://neil.fraser.name/software/lpt/">http://www.epanorama.net/counter.php?url=http://neil.fraser.name/software/lpt/</A> 
has programs that allow you to set and monitor parallel port pin states. The 
software is available for few different versions that work on Windows 98 / ME / 
NT / 2000 / XP and DOS / Windows 3.1 / 95 / 98 / ME systems. The software is 
written using Visual Basic and Euphoria programming languages and comes with 
source code. 
<P><A 
href="http://www.epanorama.net/counter.php?url=http://www.geocities.com/zoomkat/status.htm">Zoomkat's 
"El Cheapo" Parallel Port Contact/Switch Monitor</A> page at <A 
href="http://www.epanorama.net/counter.php?url=http://www.geocities.com/zoomkat/status.htm">http://www.epanorama.net/counter.php?url=http://www.geocities.com/zoomkat/status.htm</A> 
describes how to make a web controlled parallel port contact/switch monitor. The 
schematic shows how to wire up the data and status pins of the parallel port. 
The page gives you a batch file and qbasic file in the apache cgi-bin folder 
along with a copy of qbasic.exe. 
<P>
<H3>More input pins</H3>
<P>If you are not happy in just five existing printer port input pins, there are 
tricks to add more input pins. 
<P>If you are dealing with naked switches, the simplest is actually to connect 
up to 4 switches between the control outputs (pins 1,14,16, and 17) and ground, 
program the control outputs high (counting inversions), and use the control 
feedback register to read switch state (counting inversions). So program output 
high and then read feedback. 
<P><PRE>        Cn Out ------+
                     |
                   switch
		     |
        Ground ------+
</PRE>
<P>You could also use the 8 data lines in parallel port for input if you have 
bidirectional printer port. In thepry if everythign is set right. you could just 
wire switches to the data pins as above, but in practice this is not a good 
idea. To safely connect switches to data lines, you need to be sure that the 
outputs are tristated beforehand, or your switches shorting the pint go ground 
may damage the parallel port IC. This may be a problem after booting or 
rebooting where you can't be sure of the printer port operation mode (usually by 
default data pins are output). 
<P>One practical approach is to use current limiting resistors in series "just 
in case" and then some pull-up resistors too. 
<P><PRE>                         1K            4.7K
         Dn Out --------^^^^^-----+----^^^^^------ (+5v)
                                  |
                                Switch
                                  |
         Ground ------------------+--------------- (Gnd)
</PRE>
<P>
<H2><A name=registers>Parallel port software registers technical 
summary</A></H2>
<P>The following port description applies to Standard Parallel Port (SPP). 
<P>
<CENTER>
<TABLE width="80%" border=1>
  <TBODY>
  <TR>
    <TD width="15%">
      <CENTER><B>Offset</B></CENTER></TD>
    <TD width="15%">
      <CENTER><B>Name</B></CENTER></TD>
    <TD width="15%">
      <CENTER><B>Read/Write</B></CENTER></TD>
    <TD width="25%">
      <CENTER><B>Bit No.</B></CENTER></TD>
    <TD width="30%">
      <CENTER><B>Properties</B></CENTER></TD></TR>
  <TR>
    <TD vAlign=top rowSpan=8>
      <CENTER>Base + 0</CENTER></TD>
    <TD vAlign=top rowSpan=8>
      <CENTER>Data Port</CENTER></TD>
    <TD vAlign=top rowSpan=8>
      <CENTER>Write</CENTER></TD>
    <TD>
      <CENTER>Bit 7</CENTER></TD>
    <TD>
      <CENTER>Data 7</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 6</CENTER></TD>
    <TD>
      <CENTER>Data 6</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 5</CENTER></TD>
    <TD>
      <CENTER>Data 5</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 4</CENTER></TD>
    <TD>
      <CENTER>Data 4</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 3</CENTER></TD>
    <TD>
      <CENTER>Data 3</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 2</CENTER></TD>
    <TD>
      <CENTER>Data 2</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 1</CENTER></TD>
    <TD>
      <CENTER>Data 1</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 0</CENTER></TD>
    <TD>
      <CENTER>Data 0</CENTER></TD></TR></TBODY></TABLE></CENTER>This Data Register is 
simply used for outputting data on the Parallel Port's data lines (Pins 2-9). If 
your port is bi-directional, you can receive data on this address. 
<P>
<CENTER>
<TABLE width="80%" border=1>
  <TBODY>
  <TR>
    <TD width="15%">
      <CENTER><B>Offset</B></CENTER></TD>
    <TD width="15%">
      <CENTER><B>Name</B></CENTER></TD>
    <TD width="15%">
      <CENTER><B>Read/Write</B></CENTER></TD>
    <TD width="25%">
      <CENTER><B>Bit No.</B></CENTER></TD>
    <TD width="30%">
      <CENTER><B>Properties</B></CENTER></TD></TR>
  <TR>
    <TD vAlign=top rowSpan=8>
      <CENTER>Base + 1</CENTER></TD>
    <TD vAlign=top rowSpan=8>
      <CENTER>Status Port</CENTER></TD>
    <TD vAlign=top rowSpan=8>
      <CENTER>Read Only</CENTER></TD>
    <TD>
      <CENTER>Bit 7</CENTER></TD>
    <TD>
      <CENTER>Busy</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 6</CENTER></TD>
    <TD>
      <CENTER>Ack</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 5</CENTER></TD>
    <TD>
      <CENTER>Paper Out</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 4</CENTER></TD>
    <TD>
      <CENTER>Select In</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 3</CENTER></TD>
    <TD>
      <CENTER>Error</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 2</CENTER></TD>
    <TD>
      <CENTER>IRQ (Not)</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 1</CENTER></TD>
    <TD>
      <CENTER>Reserved</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 0</CENTER></TD>
    <TD>
      <CENTER>Reserved</CENTER></TD></TR></TBODY></TABLE></CENTER>The Status Port 
(base address + 1) is a read only port. Any data written to this port will be 
ignored. Please note that Bit 7 (Busy) is a active low input. 
<P>
<CENTER>
<TABLE width="80%" border=1>
  <TBODY>
  <TR>
    <TD width="15%">
      <CENTER><B>Offset</B></CENTER></TD>
    <TD width="15%">
      <CENTER><B>Name</B></CENTER></TD>
    <TD width="15%">
      <CENTER><B>Read/Write</B></CENTER></TD>
    <TD width="25%">
      <CENTER><B>Bit No.</B></CENTER></TD>
    <TD width="30%">
      <CENTER><B>Properties</B></CENTER></TD></TR>
  <TR>
    <TD vAlign=top rowSpan=8>
      <CENTER>Base + 2</CENTER></TD>
    <TD vAlign=top rowSpan=8>
      <CENTER>Control Port</CENTER></TD>
    <TD vAlign=top rowSpan=8>
      <CENTER>Read/Write</CENTER></TD>
    <TD>
      <CENTER>Bit 7</CENTER></TD>
    <TD>
      <CENTER>Unused</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 6</CENTER></TD>
    <TD>
      <CENTER>Unused</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 5</CENTER></TD>
    <TD>
      <CENTER>Enable Bi-Directional Port</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 4</CENTER></TD>
    <TD>
      <CENTER>Enable IRQ Via Ack Line</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 3</CENTER></TD>
    <TD>
      <CENTER>Select Printer</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 2</CENTER></TD>
    <TD>
      <CENTER>Initialize Printer (Reset)</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 1</CENTER></TD>
    <TD>
      <CENTER>Auto Linefeed</CENTER></TD></TR>
  <TR>
    <TD>
      <CENTER>Bit 0</CENTER></TD>
    <TD>
      <CENTER>Strobe</CENTER></TD></TR></TBODY></TABLE></CENTER>
<P>The Control Port (base address + 2) in intended as a write only port. When a 
printer is attached to the Parallel Port, four "controls" are used. These are 
Strobe, Auto Linefeed, Initialize and Select Printer, all of which are inverted 
except Initialize. 
<P>You can use the putput pins on this port also for input. The Control Port 
must be set to xxxx0100 to be able to read data, that is all pins to be +5v at 
the port so that you can pull it down to GND (logic 0) with your external 
hardware. A 4.7k resistor to +5V might be to pull the pin high when you are not 
pulling it low. The data is read form the same address you normally write data 
to. 
<P><PRE>&lt;= in   DB25    Cent    Name of         Reg
=&gt; out  pin     pin     Signal          Bit     Function Notes
------  ----    ----    --------        ---     -----------------------------
=&gt;       1       1      -Strobe         C0-     Set Low pulse &gt;0.5 us to send
=&gt;       2       2      Data 0          D0      Set to least significant data
=&gt;       3       3      Data 1          D1      ...
=&gt;       4       4      Data 2          D2      ...
=&gt;       5       5      Data 3          D3      ...
=&gt;       6       6      Data 4          D4      ...
=&gt;       7       7      Data 5          D5      ...
=&gt;       8       8      Data 6          D6      ...
=&gt;       9       9      Data 7          D7      Set to most significant data

&lt;=      10      10      -Ack            S6+ IRQ Low Pulse ~ 5 uS, after accept
&lt;=      11      11      +Busy           S7-     High for Busy/Offline/Error
&lt;=      12      12      +PaperEnd       S5+     High for out of paper
&lt;=      13      13      +SelectIn       S4+     High for printer selected
=&gt;      14      14      -AutoFd         C1-     Set Low to autofeed one line
&lt;=      15      32      -Error          S3+     Low for Error/Offline/PaperEnd
=&gt;      16      31      -Init           C2+     Set Low pulse &gt; 50uS to init
=&gt;      17      36      -Select         C3-     Set Low to select printer
==      18-25   19-30,  Ground
               33,17,16
</PRE>
<P><PRE>Port           R/W  IOAddr  Bits   Function
----           ---  -----   ----   ---------------------
Data Out        W   Base+0  D0-D7  8 LS TTL outputs
Status In       R   Base+1  S3-S7  5 LS TTL inputs
Control Out     W   Base+2  C0-C3  4 TTL Open Collector outputs
    "           W   Base+2  C4     internal, IRQ enable
    "           W   Base+2  C5     internal, Tristate data [PS/2]

Data Feedback   R   Base+0  D0-D7  normally matches Data Out *
Control Feedbk  R   Base+2  C0-C3  normally matches Control Out *
    "           R   Base+2  C4     internal, IRQ enable readback
</PRE>
<P>* NOTE: Can be different than written output state in certain cases where 
external circuit actively pulls the pin to different state parallel port tries 
to drive it. For example if output is written to be logic high, and the pin is 
shorted to ground (for example when pin is used as input), feedback reading 
tells the pin state to be low. 
<P>Note on paralle port bidirectional parallel port operation: Different 
manufacturers implement their bi-directional ports in different ways. 
<P>
<H2><A name=bootupnotes>Notes on parallel port operation during computer 
boot-up</A></H2>
<P>The parallel port operation when the computer boots up can vary somewhat 
between different computers. I don't know that that the exact operation of 
paralel port durign boot-up would be standardized anywhere. 
<P>In simplest case the parallel port data pins state mght be random in the 
beginning, and quicly set to all at logic 0 state. That's how things worked on 
old PCs usually. Some new PCs runnign modern Winodws versions seem to leave the 
parallel port pins all logic 1 (+3..5V). On some computers the pin states can 
change few times during the boot process, meaning if you have connected LEDs to 
parallel port pins you can see them flashing. For example many laptop computers 
like to send boot time diagnosing codes to the parallel port data pins. During 
the boot process the code sent to pralel port can change several times. 
Generally you can't count on the state what the parallel port pins have until 
you write a defined state to them. 
<P>When controlling some electronics with PC parallel port the best idea is the 
following sequence: 
<UL>
  <LI>1. Make sure the devices you plan to control are not powered up (so it 
  does not matterif PC data pins change state). 
  <LI>2. Boot-up the PC normally 
  <LI>3. Start your controlling software (this sets parallel port to right 
  state) 
  <LI>4. Power-up the device you plan to control </LI></UL>In this way the device 
will not get any control signal you did not design it to get, no matter what 
happens during power-up. 
<P>
<H2><A name=portversions>Notes on different parallel port versions</A></H2>
<P>The first PC-compatible parallel printer ports were unidirectional, allowing 
8-bit data transfer only from the host to the peripheral. These early Standard 
Printer Ports (SPP) implemented eight data lines and used nine handshaking 
lines, four output from the host and five input to the host. The SPP type 
implemented three registers for the control and monitoring of the data and 
handshaking lines; these are the data port, status port, and control port. The 
SPP type parallel ports are most commonly used for printers, plotters, keys, 
etc. Generally all modern parallel ports can operate in SPP mode. The maximum 
cable distance between computer and peripheral could only extend 6 feet. 
<P>Later came the PS/2 type bi-directional parallel port (BPP); this 
bi-directional port simply added the capability to read 8-bit data from the 
peripheral to the host. This parallel port type also implemented the same three 
registers as used by SPP for the control and monitoring of the data and 
handshaking lines; these are the data port, status port, and control port. In 
addition to norma operations there is one extra bit on control port that can set 
the data pins to output or input mode. 
<P>The IEEE 1284 standard, "Standard Signaling Method for a Bi-directional 
Parallel Peripheral Interface for Personal Computers", sought to correct the 
major drawbacks to the original parallel port structure. IEEE 1284 sets 
standards for the cable, connector, and electrical interface, which guarantee 
interoperability between all parallel peripherals. The specified configuration 
ensures that data integrity is maintained, even at the highest data rates, and 
at a distance of up to 30 feet. Two new types of parallel ports with extended 
features are now available: the Enhanced Parallel Port (EPP) and the Extended 
Capabilities Port (ECP). EPP and ECP are standards defined by IEEE 1284 and 
Microsoft ECP Specifications. Both EPP and ECP ports may be operated in the SPP 
and bi-directional modes; however, operation in their feature modes requires 
both compatible peripherals and appropriate software drivers. Generally, EPP is 
used primarily by non-printer peripherals, CD ROM, tape drive, hard drive, 
network adapters, etc., while ECP is aimed at newer generation of printers and 
scanners. Currently, new products have been released having support for a 
mixture of these protocols. With EPP, the software driver may intermix read and 
write operations without any overhead or protocol handshaking. With the ECP 
protocol, changes in the data direction must be negotiated. 
<P>The I/O interface on EPP and ECP ports is somewhat different from normal I/O 
port controls. They can be viewed as supersets of SPP. An EPP parallel port 
implements two registers in addition to the standard data, status, and control 
ports. The outputs are tri-stateable outputs allow the EPP port to be used as a 
data bus for multiple EPP compatible devices. The entire data transfer occurs 
within one ISA I/O cycle. An ECP parallel port features two special modes, 
namely data and command cycles. In the Parallel Port Data FIFO Mode, data 
written or DMAed to a 16-byte FIFO is automatically transferred to a peripheral 
using standard parallel port protocol. The ECP Parallel Port Mode allows 
bi-directional data transfer using automatic interlocked handshaking via the ECP 
protocol. When the ECP protocol was proposed, a standard register implementation 
was also proposed through Microsoft ECP Specification. ECP protocol is meant to 
be driven by DMA rather than explicit I/O operations. ECP protocol is commonly 
seen on parallel port on motherboards and on high-end parallel port cards that 
plug to ISA bus, but often not on PCI bus parallel port cards (because PCI bus 
does not support ISA bus type DMA transfers). 
<P>Many modern parallel ports support SPPl, BPP, ECP and EPP modes, or at least 
most of them. On some systems and interface cards ther has been even options to 
select in which operation mode it work (so avoid any potential problems). 
<P>On the simple I/O controlling operations I have described in this document 
there are no benefits of any better than SPP operation modes. Usually the 
controllign of the parallel port shoudl work with simple I/O routines directly 
for most of the ports, no matter what operation modes they support. In some rare 
cases if you have problems, try setting the port to SPP mode, it should be 
guaranteed to work correctly with the I/O controlling examples I have given. 
<P>
<H2><A name=pcibus>Notes on PCI bus parallel port cards</A></H2>
<P>I have not played much with parallel port card that plug to PCI bus, but I 
have seen cases where the parallel port that plugs to PCI bus does not work 
properly with legacy software, meaning a software that control parallel port 
directly at I/O bus level. It seems that the PCI parallel ports are different 
hardware than normal parallel ports, at leasts sit at different I/O address. The 
parallel port driver (comes with the card or built into Windows) makes the 
parallel port card to look like normal parallel port to high level applications, 
enven though the internal operation is different than in traditional ports. I 
have bene told that in systems where there was both ISA and PCI bus, the I/O 
address range normally used for parallel ports was limited to be only accessable 
though ISA bus, meaning that the ports on PCI bus needed to be on different I/O 
address (higher I/O address). Nowadays when the ISA bus has practically 
dissapeared from desktop computers, and things coudl be different. I have seen 
as <A 
href="http://www.epanorama.net/counter.php?url=http://www.lpt.com/Products/DualPciParallelAdapter/dualpciparalleladapter.htm">http://www.epanorama.net/counter.php?url=http://www.lpt.com/Products/DualPciParallelAdapter/dualpciparalleladapter.htm</A> 
a parallel port card that claims to Automatically Configure itself for an 
available I/O address (3BC, 378or 278), avoiding the need for reconfiguration 
for legacy parallel port peripherals (e.g. Zip. Drives). This kind of card might 
work with the examples above. Some other cards seem to work on different 
addresses. 
<P>For example web page <A 
href="http://www.epanorama.net/counter.php?url=http://www.tharo.com/nettroub/pci_parallel_adapter.htm">http://www.epanorama.net/counter.php?url=http://www.tharo.com/nettroub/pci_parallel_adapter.htm</A> 
seems to show some details of CyberParallel PCI adapter. This CyberParallel PCI 
adapter seems to be in the example at 1088-108F and 1080-1083 IO addresses 
(addresses in hex). According other details it coudl be that the card itself 
would work similarly to normal printer port, but the I/O address is just 
different. If you have a PCI parallel port card, this could be one option. Find 
out the I/O port address of it, and then try my parallel port controlling 
examples with that I/O address. 
<P>The web page <A 
href="http://www.epanorama.net/counter.php?url=http://www.dta.it/support/manuals/html/dcl/group__addr.html">http://www.epanorama.net/counter.php?url=http://www.dta.it/support/manuals/html/dcl/group__addr.html</A> 
titled <A 
href="http://www.epanorama.net/counter.php?url=http://www.dta.it/support/manuals/html/dcl/group__addr.html">Parallel 
port address on ISA or PCI bus</A> lists thw following I/O addresses for 
different parallel ports (both ISA and PCI port addresses listed): <PRE>#define  LPT0   0x3BC 
  EPP Standard parallel port at 3BCH address. 

#define  LPT1   0x378 
  EPP Standard parallel port at 378H address. 
 
#define  LPT2   0x278 
  EPP Standard parallel port at 278H address. 
 
#define  LPT3   0x27C 
  EPP Standard parallel port at 27CH address. 
 
#define  LPT4   0x26C 
  EPP Standard parallel port at 26CH address. 
 
#define  LPT5   0x268 
  EPP Standard parallel port at 268H address. 
 
#define  PCI0   0x9800 
  EPP Standard parallel port at 9800H address. 
 
#define  PCI1   0xA000 
  EPP Standard parallel port at A000H address. 
 
#define  PCI2   0xA400 
  EPP Standard parallel port at A400H address. 
 
#define  PCI3   0xA800 
  EPP Standard parallel port at A800H address. 

#define  PCI4   0xB000 
  EPP Standard parallel port at B000H address. 
 
#define  PCI5   0xB400 
  EPP Standard parallel port at B400H address.
</PRE>
<P>I have not tested those I/O addresses myself. 
<P>On modern Windows systems (I tested in Windows 2000) you can get to know the 
parallel port I/O addrss through device manager. First open the device manager 
(start - settings - control panel - system - hardware - device manager). Then 
select there the parallel port you are interrested from Ports (COM &amp; LPT) 
section. With mouse right button you can get menu where you select Properties. 
From there select Resources where you should see a screen like this: 
<P><IMG alt="Windows device control IO address view" 
src="Parallel port output_files/io_properties.gif"> 
<P>The details in this image are from the parallel port built into the 
motherboard of my PC. 
<P>Hopefully this information I have provided is useful to somebody as a 
starting point of experiments. If anyone has more details, those are wellcome. 
<P>
<H2><A name=usbnotes>Notes on USB parallel port adapters</A></H2>
<P>The USB-Parallel Port Adapter enables users to connect parallel port 
interfaced devices like printers to a desktop or laptop PC via the PC's USB 
port. As USB becomes increasingly popular, and newer laptop PCs are without 
parallel and/or serial ports. Older PCs tend to have a parallel port but no USB, 
newer PCs have both, and tomorrow's PCs will typically have USB but no parallel 
port. 
<P>The parallel port through this kind of adapter looks pretty same as normal 
parallel port for high level programs on Windows system. The low level 
implementation of them is completely different, and the low level I/O control 
operations described in this document do not work with USB parallel port 
adapters. 
<P>At this port you can forget using the USB parallel ports for your own harware 
controlling. In some cases USB Parallel Printer Adapter can be useful. With USB 
Parallel Printer Adapter you can attach your printer to your USB port and make 
room for your own circuits on the existing legacy parallel ports on your system. 

<P>USB parallel ports are generally targeted for driving normal printers, and 
not designed for anything else. When using a HP Officejet or other multifunction 
product, this USB to parallel port adapters will only allow access of the 
printer capability. It will not work with the faxing and scanning capabilities 
of the multifunction product. And it will either work for the direct output pin 
controlling described in this document. 
<P>If your computer does not have parallel port anymore, and all you can use is 
USB, then maybe you need to consider making the I/O you need with a dedicated 
idustrial I/O card that plugs to USB port. This kind of products ara available, 
and they typically come with their own controlling software and their own 
programming libraries that can be used to control them. 
<P>
<H2><A name=documentlinks>Other documents worth to check</A></H2>
<UL>
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.beyondlogic.org/spp/parallel.htm">Interfacing 
  the Standard Parallel Port</A> - This is a very complete introduction to PC 
  parallel ports and interfacing to them. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.logix4u.net/inpout32.htm">Inpout32.dll 
  for WIN NT/2000/XP</A> - This article describes how to talk to parallel port 
  with Inpout32.dll library on WIN 98/NT/2000/XP systems. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.faqs.org/docs/Linux-mini/IO-Port-Programming.html">Linux 
  I/O port programming mini-HOWTO</A> - This HOWTO document describes 
  programming hardware I/O ports and waiting for small periods of time in 
  user-mode Linux programs running on the Intel x86 architecture. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.bb-elec.com/tech_articles/parallel_port_explained.asp">Parallel 
  Port Explained</A> - This document desxrubes the differences between different 
  parallel port types like SPP, BPP, EPP and ECP. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.logix4u.net/parallelport1.htm">Parallel 
  port Interfacing Tutorial</A> - This is a good general introduction to 
  parallel port interfacing. This document has a sample program in VC++. 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.luberth.com/cstep/parallel.htm">Parallel 
  Port Hardware Properties</A> - This document describes the parallel port 
  programming registers. 
  <LI><A href="http://www.epanorama.net/links/pc_interface.html#parallel">PC 
  parallel port links at ePanorama.net</A> 
  <LI><A href="http://www.epanorama.net/links/project_pc.html#pc_parallel">PC 
  parallel port circuit links</A> 
  <LI><A 
  href="http://www.epanorama.net/counter.php?url=http://www.programmershelp.co.uk/printerport1.php">Printer 
  Port interfacing 1</A> - The description in this document involve building a 
  simple circuit and flashing leds on/off. The examples use various programming 
  languages such as C , C++ , QBasic , Visual Basic and even debug from DOS. 
  </LI></UL>
<HR>

<ADDRESS><A 
href="http://www.epanorama.net/counter.php?url=http://www.hut.fi/~then/">Tomi 
Engdahl</A> &lt;then@delta.hut.fi&gt;</ADDRESS><BR></DIV>
<DIV class=spacer>&nbsp;</DIV><!-- Footer section begins -->
<DIV class=footer>
<DIV>
<DIV class=googlebanner>
<SCRIPT type=text/javascript><!--
google_ad_client = "pub-3257650267345122";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text_image";
google_ad_channel ="5495687474";
google_color_border = "336699";
//--></SCRIPT>

<SCRIPT src="Parallel port output_files/show_ads.js" 
type=text/javascript>
</SCRIPT>
</DIV>
<DIV class=hline>
<HR>
</DIV>
<CENTER>
<DIV style="PADDING-LEFT: 25px; WIDTH: 730px">| <A class=btext 
href="http://www.epanorama.net/submitSite.php">Submit site</A> | <A class=btext 
href="http://www.epanorama.net/index.php?index=info">Info</A> | <A class=btext 
href="http://www.epanorama.net/index.php?index=advertising">Advertise</A> | <A 
class=btext href="mailto:webmaster@epanorama.net?subject=Feedback">Feedback</A> 
| <A class=btext 
href="http://www.epanorama.net/index.php?index=disclaimer">Disclaimer</A> | <A 
class=btext href="http://www.epanorama.net/index.php?index=privacy">Privacy</A> 
| <A class=btext href="http://www.epanorama.net/index.php?index=ad_faq">Ad. 
FAQ</A> | <A class=btext 
href="http://www.epanorama.net/index.php?index=terms">Legal Notice</A> |</DIV>
<DIV class=btext style="PADDING-LEFT: 25px; WIDTH: 730px">Copyright  
1994-2007</DIV><!-- Copyright Section --></CENTER></DIV>
<DIV>&nbsp;</DIV></DIV><!-- Kontera ContentLink -->
<SCRIPT type=text/javascript>
var dc_UnitID = 14;
var dc_PublisherID = 16320;
var dc_AdLinkColor = 'blue';
var dc_isBoldActive= 'no';
var dc_adprod='ADL';
</SCRIPT>

<SCRIPT src="Parallel port output_files/KonaLibInline.js" 
type=text/javascript></SCRIPT>
<!-- Kontera ContentLink --><!-- Footer section ends here --><!-- Kontera ContentLink -->
<SCRIPT type=text/javascript>
var dc_UnitID = 14;
var dc_PublisherID = 16320;
var dc_AdLinkColor = 'blue';
var dc_isBoldActive= 'no';
var dc_adprod='ADL';
</SCRIPT>

<SCRIPT src="G:\Parallel port output_files\KonaLibInline(1).js" 
type=text/javascript></SCRIPT>
<!-- Kontera ContentLink --></DIV></BODY></HTML>
